[{"title":"像素","url":"/2019/03/29/pixel/","content":"\n像素不是一个点或方块。而是一种抽象概念，是一个抽象取样。\n\n像素的定义是上下文敏感的。比如，在打印机上的物理像素是打印机的墨点。在显示器上的物理像素是显示器的点距。\n\n> 没有什么卵用的小支持：pix(picture) + el(element) = pixel\n\n谈论像素，还需要讲到另外几个概念。\n\n## **DPI**\n\nDots Per Inch。指的是每英寸上的点的数量。\n\n## **PPI**\n\nPixel Per Inch。指的是每英寸上的像素的数量。PPI越高就是一英寸的点点越多。\n\n但是因为像素的概念是上下文敏感的。虽然他们有不同的定义，但PPI和DPI有时是可以互换的。在显示器上他们的概念就是相同的。\n\n\n显示的PPI，如果确定屏幕尺寸和分辨率是可以利用公式计算的。\n\n计算公式是\n\n```\nPPI = dp / di = Math.sqrt(wp * wp + hp * hp) / di\n\n// dp 是屏幕对角线的分辨率\n// wp 是屏幕横向分辨率\n// hp 是屏幕纵向分辨率\n// di 是屏幕对角线的长度(单位是英寸)\n```\n\n## **Device Pixel**\n\n这指的是显示器上的单个物理点。屏幕的话，从出厂起，上面的物理像素点就固定了，单位是pt。\n\n> 我们通常所说的显示器分辨率，其实是指桌面设定的分辨率，而不是显示器的物理分辨率。只不过现在液晶显示器成为主流，由于液晶的显示原理与CRT不同，只有在桌面分辨率与物理分辨率一致的情况下，显示效果最佳，所以现在我们的桌面分辨率几乎总是与显示器的物理分辨率一致了。\n\nW3C中讲到，在CSS单位中物理单位是 [1pt = 1/72 inch](https://www.w3.org/TR/CSS21/syndata.html#length-units)。\n\n但是包包有点怀疑这个1pt的真正长度。因为iPhone8的宽度是2.65inch。所以对应宽度是2.65/(1/72)=190.8pt。但是实际测试并没有那么宽。同时也是会随着分辨率设定而变。所以包包很怀疑他说的英寸其实是逻辑英寸。\n\n那么什么是逻辑英寸嘞。\n\n## **逻辑英寸**\n\n那么逻辑英寸是怎么来的嘞。\n\n这就要提到在印刷中，字号的度量衡是点（points）。\n\n1pt = 1/72inch (从历史上看一个点的确切度量是变化的)\n\n比如一个12点的文字是为了适应1/6inch的文本行设计的，但并不是每个字母都是那么高的，比如说Å。所以为了能正确展示文字，会在文字的两边留出行距。\n\n{% asset_img image.png %}\n\n上图是一个72pt的文字。然而把它放在展示的时候，因为像素尺寸不一，所以文字展示也可能会不同。\n\n像素的大小主要依赖分辨率和显示器物理尺寸。因此，物理英寸就不是一个有用的度量衡了。因为物理英寸和像素之间没有固定关系。所以字体以逻辑单位测量。一个72pt的字体被定义为一个逻辑英寸高。然后把逻辑英寸转为像素。多年来，windows使用的都是：1个逻辑英寸 =  96px。所以一个72pt的字体会被渲染为96px高。一个12pt的字体是16px高\n\n所以得出 **12pt = 12/72逻辑英寸 = 1/6逻辑英寸 = 96/6px = 16px**\n\n这个缩放因子被描述为96个点每英寸。在电脑展示中，更准确的说法是96个像素每逻辑英寸\n\n> 另外在一本记不起名字的书中提到几点。\n1. 真实的物理尺寸需要依据显示器与操作系统/用户设置而定。\n2. 而点距决定了物理像素的尺寸，从而可以确定逻辑英寸的物理尺寸。\n3. 因为显示器的点距不会改变，所以逻辑英寸的物理大小可能在高dpi的屏幕上就大一点，因此会包含更多的点。这样的设计会让你在不同显示器上设置的宽度都是看起来一样的。\n\n> 没有什么卵用的小知识：由于实际像素大小不同，因此在一台显示器上可读的文本在另一台显示器上可能太小。此外，人们有不同的偏好 - 有些人喜欢更大的文字。 因此，Windows允许用户更改DPI设置。 例如，如果用户将显示设置为144 DPI，则72磅字体的高度为144像素。 标准DPI设置为100％（96 DPI），125％（120 DPI）和150％（144 DPI）。 用户还可以应用自定义设置。 从Windows 7开始，DPI是按用户设置。\n\n\n好的回到正题。我们实际到css中使用的是 CSS Pixel\n\n## **CSS Pixel**\n\nCSS像素也可以说是逻辑像素\n\n[1px = 0.75pt](https://www.w3.org/TR/CSS21/syndata.html#length-units)\n\n这在CSS单位中是一个绝对单位。\n\n在同一设备上，每一个CSS像素所代表的物理像素是可以 变化的。在不同设备上，每一个CSS像素所代表的物理像 素也可以是不同的。\n\n由于不同物理设备的物理像素大小不一，所以CSS认为浏览器 应该对CSS中的像素进行调节。使浏览器中1px的大小在不同的 物理设备上看上去差不多大，从而使阅读体验一致。\n\n对于CSS设备，这些维度要么锚定（i）通过将物理单位与其物理测量相关联，或者（ii）通过将像素单位与参考像素相关联来锚定。对于打印介质和类似的高分辨率设备，锚单位应该是标准物理单位之一（英寸，厘米等）。对于分辨率较低的设备和具有不寻常观看距离的设备，建议将锚单位作为像素单元。对于这样的设备，建议像素单元参考最接近参考像素的设备像素的整数。\n\n注意，如果锚单位是像素单位，那么物理单元可能与它们的物理测量值不匹配。或者，如果锚单位是物理单位，像素单位可能不会映射到所有设备像素。\n\n注意，这个像素单位和物理单位的定义与以前版本的CSS不同。特别是，在以前的CSS版本中，像素单位和物理单位之间并没有固定的比例关系:物理单位总是与它们的物理测量值相关联，而像素单位会随着参考像素的最接近而变化。(之所以做出这样的改变，是因为太多的现有内容依赖于96dpi的假设，而打破这个假设就会破坏内容。)\n\n为了达到这一点浏览器可以直接按照设备的物理像素大小进行换算。所以那个pt和真实的pt其实是对不上的。\n而CSS规范中使用参考像素进行换算。\n\n1参考像素是从一臂之遥看96dpi的设备上1像素的视角。算出来 差不多1px是0.26mm\n\n{% asset_img pixel1.png %}\n\n一般来手臂是28inch长（71cm），所以可以算出大概这个视角是0.0213°。然后从一个胳膊的距离看过去1px相当于0.26mm（1/96inch）\n\n计算公式： **(1/96)in / (28in * 2 * PI / 360deg) = 0.0213°**\n\n好的。最后让我们来了解一下⬇️\n\n## **Device Pixel Radio**\n\n这是设备像素比。等于 物理像素 / CSS像素。\n\n设备像素比与ppi相关，一般是ppi/160的整数倍。因为看手机的最佳距离据说是18inch，根据参考像素推算出来，理想的ppi是（28/18）* 96 ≈ 每英寸150像素。\n\n请看下面这个图\n\n{% asset_img phone.jpg %}\n\nIphone7 都是宽是2.3英寸高7.1英寸。实际上他是每行有750个像素，每列有1334个像素。右边假设ppi是左边的一半。方块是 326*326px。\n\n为了让他们看起来一样，所以就要缩一下。反过来说一张200 * 200的图片，如果放在2倍屏上，为了看起来和1倍屏物理大小一样，所以被放大了一倍。这就是为什么图片会糊了……\n\n图像显示了影响设备的分辨率的像素单元:1 px的面积1 px是由一个单一的点在一个低分辨率的设备(例如,一个典型的计算机显示器),在同一地区覆盖了16点高分辨率设备(如打印机)。\n本来图片1个像素对应一个点，现在1个像素被分成了一大堆点。\n\n所以这就是为什么一个图片不用N倍图的话在高分辨率设备上会变糊了。\n\n## 通过CSS使1倍图在高分辨率屏幕上尽量清晰的方法\n\n可以使用属性 `Image-rendering`\n\n```\nimage-rendering: auto;\nimage-rendering: crisp-edges;\nimage-rendering: pixelated;\n```\n\nauto：默认值， 图像缩放时以外观优先。颜色过渡\"平滑\"算法是很合适的,比如双线性插值算法。 这种适合于照片。 从 1.9版本起 (Firefox 3.0), Gecko 使用双线性插值算法(高质量)。\n\ncrisp-edges：图像缩放时,该算法保留图像的对比度和边缘.在不平滑过渡的颜色中引入模糊图像. 这常用于像素级作品\n\npixelated：当缩放图像时, 使用\"nearest neighbor\"或类似算法, 所以图像将由大像素组成. 当缩小时，效果与'auto'值一样。\n\n此属性不指示要使用的任何特定缩放算法。 例如，使用图像渲染：auto，用户代理可以默认使用双线性插值缩放图像，在高负载情况下切换到最近邻插值，并切换到高质量缩放算法，如Lanczos插值，用于静态图像 没有移动或改变。 类似地，对于“图像渲染：清晰边缘”，用户代理可以默认使用最近邻插值来缩放图像，并在低负载情况下切换到EPX插值。[查看](https://drafts.csswg.org/css-images-3/#valdef-image-rendering-crisp-edges)\n","tags":["css"]},{"title":"浅入浅出富文本编辑器","url":"/2018/12/17/rich-text-editor/","content":"\n首先让我们思考一下，如果现在产品需要在页面上提供富文本编辑器应该怎么实现🤔\n\n一般来说方式有以下几种。\n\n1. 我们可能会想到借助一些编辑器框架、编辑器组件。比如说是ueditor、tinyMCE、draftjs等等。\n2. 或者，我是一个造轮子资深爱好者，决定自己实现。通过使用HTML自带的属性contenteditable。\n\n没错，现在市面上流行编辑器的也可以分为这两个种类。\n\n当然如果你只是想实现一些简单的功能。比如像有人一样，通过@去metion一个用户，通过#加上日志的类型。\n\n那么也可以使用textarea，然后通过绝对定位去处理文本的高亮，以及待选列表的展示等等。\n\n但是这也随之带来了一些问题。\n\n比如在Facebook2016年介绍Draftjs的演讲里，他说Facebook早期也是通过这种方式去metion一个人的。\n\n首先textarea自带一些小问题——不会随着输入而增高等等。\n\n但是他们发现就有无法正确定位的bug，redo、undo、复制黏贴破坏了metion。\n\nhttps://signavio.github.io/react-mentions/master/\n可以看一下React-Metion的这个demo，当我们去破坏metion的时候，这个体验就变得不符合预期了\n\n好，我们现在来介绍一些现在主流的几种编辑器的实现。\n\n**一种，就是基于HTML的contenteditable实现。**\n\n比如说我们刚才提到的ueditor、tinyMCE。\n\n这个属性兼容性非常优秀。没记错的话从IE5开始浏览器就支持这个属性。它允许用户在普通标签里面编辑富文本的内容。同时还有document.execCommand这个更加优秀的API，可以支持格式化文本。后面还新增了比如events、caret、plaintext-only这样的属性，让你控制编辑器只能输入纯文本等等。\nhttps://w3c.github.io/editing/contentEditable.html#contenteditable\n\n不过经过广大开发者多年的实践。我们很难说这个contenteditable是好还是坏。\n因为这个坑爹属性在不同浏览器下表现不一致。一个回车，可能出现一个`<p>`，可能是`<div>`，也有可能是`<br>`。\n\n> https://www.oschina.net/translate/why-contenteditable-is-terrible?cmp\n> https://medium.com/content-uneditable/contenteditable-the-good-the-bad-and-the-ugly-261a38555e9c\n\n这导致你没有办法把视图抽象成一个模型。另外存储数据的时候也是，因为没有办法抽象，你在存储数据的时候就需要存储一段HTML。之后你可能又要花很多精力去处理安全问题。\n\n现在我们在做IM的时候就遇到这样的问题，业务爸爸们想要富文本，但是DBA不同意啊，这个字段太长啦！不存不存我们不存！\n\nOK，假如我们的字段够长，DBA同意你存储HTML string。现在想想如果我们想要他输入的内容符合我们的预期行为该怎么办。比如我们回车就是要p标签。第一个想到的可能是监听onKeyPress事件，如果有回车，就手工插入一个p。https://codepen.io/eleanormao/pen/QJezvG\n然后坑爹了。redo和undo事件被破坏了。\n\n这个问题在有道云笔记的分享里面也有提到。https://sq.163yun.com/blog/article/168068797113712640\n使用document.execCommand对内容修改时，浏览器内部会对该contenteditable区域维护一个undo/redo栈，使得每一个修改行为可以撤销和重做。如果一旦使用了document.execCommand之外的DOM API修改内容，就会破坏undo/redo栈的连续性，导致撤销和重做出错或失效。\n\n然后你又需要花费很多事件去处理这个问题。另外因为每个浏览器中行为都不一样，你可能在chrome里面实现了，但在火狐里面就有bug了。之后你可能就因为把项目延期了几个月被公司优化掉了。\n\n当然contenteditable的开发者做了很多的努力，所以上述的这些优秀的插件，帮我们解决了这些问题。\n\n但是不得不说如果有朝一日产品需要协同编辑，或者自定义一些类型的节点，那可能又要遭遇天坑了。\n\n还有作为一个React开发者，我们会发现它不React。因为DOM===State。\n\n**第二种，就是超越了contenteditable。**\n\n利用了contenteditable，但是不依赖contenteditable。它们在内部自定义一套数据模型，与视图对应。做到了数据与视图的分离。让contenteditable变得可控。\n\n这样类型的编辑器，通常可以通过传入一个schema去做一个定制内容，还有因为他变得可控，解决了contenteditable编辑器不能协同编辑、很难自定义的问题。\n\n另外因为他其实维护的不是DOM本身，而是一组数据，所以序列化Markdown、存储数据的都变得简单。\n\n这里我主要介绍Slate。\n\n它和Draft.js一样，他不能开箱即用，不是一个应用。他是一个可完全定制化的富文本编辑器框架。可以把它看做是一个基于React和Immutable的，可插拔的contenteditable。\n它利用了React，不需要再去重新构建一套视图的轮子。利用Immutable实现了不可变的数据模型，这点和Draft.js一样。\n\n这里介绍一些Slate的几个原则。\n1. 插件是一等公民。它的所有逻辑，都是通过一系列的plugins完成。甚至它的核心代码其实也是一个plugin。它把一系列插件的List叫做插件栈。和express和koa的中间件比较类似。当处理事件和富文本的时候它会依次通过插件去处理请求。\n2. scheme-less的内核。Slate 的核心逻辑并不对你所编辑的数据结构做任何假设，这意味着你在需要应对复杂场景时不会被编辑器预置的内容所束缚\n3. 嵌套文档模型。一个前端工程师不可能不熟悉DOM结构，所以它设计时，也把数据结构竟可能的镜像DOM结构。\n比如document下面是block，还有inline、text、range、selection。很好理解，降低了学习成本。同时嵌套的递归的结构，也可以很好的支持复杂的DOM结构。\n比如说表格之类的。还有我们知道自由都是建立在规则的基础上的嘛，所以Slate也为数据结构定义了一些强制性的规则。比如说不能有相邻的Text节点、inline节点下面不能有block节点等等。当你改变内容的时候还会自动强制执行normalizer，使数据结构吻合预期。\n4. 与DOM平行。数据模型是建立在DOM基础上的，即，文档是一个嵌套的树。有selection和ranges。并且暴露了所有标准的事件handlers。这使插入例如表格和引用变得可能。任何你在DOM里面能做的，都可以在Slate里面实现。\n5. 无状态的view和不可变的数据。通过React和Immutable.js。Slate编辑器使用构建了一个无状态的、数据不可变的编辑器。\n6. 直观的变更。这里也可以看到Slate是一个十分注重API表现力的框架。他把所有对富文本的操作都变成对editor对象的命令。并且所有的操作都是链式的。\n{% asset_img image.png %}\n7. 可协同编辑的数据模型。\n8. 消除了内核边界。因为用了好多插件~\n\n我们可以发现，有了M，有了V，其实Slate就是一个C。在看他源码的时候也可以发现他的代码分别放在models、controller文件夹下面。\n\nSlate提供了React组件slate-react，他暴露出一个Editor组件，不过这个组件其实是他controller editor.js的实例。传入的属性（比如onKeyDown、Schema、巴拉巴拉）其实也是一系列插件，Editor实际上是用来管理这些插件的。\n\n盗一张图来描述一下Slate的数据流动。讲一下他是专门做到视图的统一的。\n他的onChange事件其实是滞后的、异步的，其实改变已经反映在视图上了，然后再传递给的onChange。\n\n{% asset_img image1.png %}\n\n","tags":["javascript"]},{"title":"webpack打包速度优化","url":"/2017/09/11/webpack-optimize/","content":"\n看了一些文章，还有实际使用中，总结一下\n\n* webpack1的可以使用happypack\n* 其他可以尽量升级webpack和打包用的依赖项升级到最高版本\n* 删除废弃的引用包\n* 不要为了小功能使用大号的依赖\n* 不要同时使用 babel-runtime 和 babel-polyfill\n* 慎用css-module\n* DedupePlugin, OccurrenceOrderPlugin(npm2&webpack1)\n<!-- * commonsChunkPlugin增加minChunks参数配置 -->\n* external, exclude, resolve.modules\n* dllPlugin(和commonPlugin二选一说)\n* webpack-uglify-parallel多核并行压缩\n* -json 分析打包状况后，再用PrefetchPlugin优化(但是效果一般)(webpack-visualizer-plugin分析用)\n\n","tags":["javascript","webpack"]},{"title":"2017-9-8","url":"/2017/09/08/2017-9-8/","content":"\n昨天又遇到了静态资源出不来的问题，不过这次报的错`ERR_EMPTY_RESPONSE`\n\n我就说先看看磁盘满了没有嘛_(:з」∠)_\n\n不理我\n\n结果果然是转发oss那台满了…\n\n\n","tags":["diary"]},{"title":"require别名(alias)HACK解析","url":"/2017/09/03/alias-require-hack/","content":"# 前言\n上一篇中我们已经探讨了一下如何在node之中使用别名require模块，里面提到了几种HACK方法，这里来解释一下是通过什么原理hack的。\n\n# module模块\n其实吧，读过module的源码就懂了…因为require是靠module模块\b实现的，所以几种hack方式都是依靠hack\b module模块来搞的。\n因为很多人都有分享过module源码的解析，所以下面就不讲累赘的内容了\n（以下用的代码来自于node6.5.0，包包只看了下6.x及以上的代码）\n\n## _initPaths\n可以看到源码中，首先Module模块首先运行了`_initPaths`方法\n{% asset_img initPaths.png node.js %}\n{% codeblock module.js lang:javascript https://github.com/nodejs/node/blob/master/lib/module.js%}\nModule._initPaths = function() {\n  const isWindows = process.platform === 'win32';\n\n  var homeDir;\n  if (isWindows) {\n    homeDir = process.env.USERPROFILE;\n  } else {\n    homeDir = process.env.HOME;\n  }\n\n  var paths = [path.resolve(process.execPath, '..', '..', 'lib', 'node')];\n\n  if (homeDir) {\n    paths.unshift(path.resolve(homeDir, '.node_libraries'));\n    paths.unshift(path.resolve(homeDir, '.node_modules'));\n  }\n\n  var nodePath = process.env['NODE_PATH'];\n  if (nodePath) {\n    paths = nodePath.split(path.delimiter).filter(function(path) {\n      return !!path;\n    }).concat(paths);\n  }\n\n  modulePaths = paths;\n\n  // clone as a read-only copy, for introspection.\n  Module.globalPaths = modulePaths.slice(0);\n};\n{% endcodeblock %}\n这段代码中，把全局node路径和环境变量中的`NODE_PATH`和当前app的node路径收集在了一起，\n在后来查找文件位置的时候会从这些路径查找。\n\n知道了它会使用`NODE_PATH`，所以可以设定`NODE_PATH`来缩短一大堆`../../`\n\n（其实我觉得如果可以修改`modulePaths`变量就更好了，可惜是个变量，而且`Module.globalPaths`这个变量根本没在用，摔！）\n\n## require\nrequire模块用的方法就是：\n{% codeblock module.js lang:javascript https://github.com/nodejs/node/blob/master/lib/module.js%}\nModule.prototype.require = function(path) {\n  assert(path, 'missing path');\n  assert(typeof path === 'string', 'path must be a string');\n  return Module._load(path, this, /* isMain */ false);\n};\n{% endcodeblock %}\n因此可以，拦截这个方法，然后修改传入的path\n如：\n```javascript\n// 假设我们想要这样简写 require('@/abc.js')\nvar nodePath = require('path')\nvar _old_require = Module.prototype.require\n\nModule.prototype.require = function(path) {\n    if(path.startsWith('@')){\n        path = nodePath.join(__dirname, path.replace(/^@/, ''))\n    }\n    return _old_require(path)\n}\n```\n\n## _findPath\n因为`Module.prototype.require`调用了`Module._load`方法，`Module._load`方法调用了`Module._resolveFilename`方法，\n然后通过`Module._findPath`方法获取模块地址，如果没有地址就会报错，所以可以hack`_findPath`方法（就是node6.x&以上才有这个方法）\n{% asset_img findPath.png node.js%}\n可以看到如果request变量(其实就是你写的require的路径)是绝对路径，paths就是`['']`，<br>\n也就是说直接指定了模块了路径，可以省去下面一大堆和预设好的path拼来拼去的过程了，不过给paths增加可选的路径也是个方法\n不过我比较怕懒，所以我直接就把路径拼成绝对路径：\n```javascript\n// 假设我们想要这样简写 require('@/abc.js')\nvar nodePath = require('path')\nvar _old_findPath = Module._findPath\n\nModule._findPath = function(request, paths, isMain){\n    if(request.startsWith('@')){\n        request = nodePath.join(__dirname, path.replace(/^@/, ''))\n    }\n    return _old_findPath(request, paths, isMain)    \n}\n```\n\n## _nodeModulePaths + _resolveFilename\n是的还有这种组合技，不过我觉得实在比较麻烦 = =\n代码可以看这里[module-alias](https://github.com/ilearnio/module-alias/blob/master/index.js)\n因为`Module._nodeModulePaths`只会在`Module._resolveFilename`成功之后和没有parent的时候调用，关改这个还不管用，\n\n修改`Module._resolveFilename`其实单用也可以，可以把传入的路径修改为绝对路径，然后`Module._findPath`跑的时候就可以直接用了，其实和修改`Module._findPath`一样\n\n\n# 最后\n我用的方法是修改`_findPath`方法做到的，其中还添加了缓存什么的<br>\n这里安利一下自己的插件[`node-require-alias`](https://www.npmjs.com/package/node-require-alias)<br>\n支持node6.0以上<br>\n使用方法：\n```javascript\nconst path = require(\"path\")\nrequire('node-require-alias').setAlias({\n    \"@\": \bpath.join(__dirname, \"this/is/a/path\")\n})\n// or require('node-require-alias').setAlias(\"@\", path.join(__dirname, \"this/is/a/path\"))\n```    \nrequire模块时候↓\n```javascript\nrequire('@/abc.js')\n```\n\n欢迎来PR(づ￣3￣)づ╭❤～\n\n","tags":["javascript","node"]},{"title":"使用node时为require设置别名(alias)","url":"/2017/09/03/set-alias-for-require-for-node/","content":"# 前言\n由于\b本包包是个很懒惰的人，然后我们有些个项目设计的不是很好，所以导致写代码的时候有很多这样的代码:\n\n```javascript\nrequire('../../../../../../foo.js');\n```\n写的时候数那个小点点感觉人都要死\b了😤<br>\n这种时候如果写node能像用了`webpack\b`(and so on)那样\b能够`require`别名就好了。\n比如这样:\n\n```javascript\nrequire('modules/foo.js');\n```\n于是我搜寻了几种方法。\b\n\n# 来自[branneman](https://gist.github.com/branneman)总结的方法\n**以下内容来自于github上一名叫做branneman的同志的总结，我为他的内容进行了随性的翻译**\n\n原文可查看[这里](https://gist.github.com/branneman/8048520)\n\n## 1. Symlink\n\"偷\"自[focusaurus / express_code_structure # the-app-symlink-trick](https://github.com/focusaurus/express_code_structure#the-app-symlink-trick)\n\n1. 在应用的`node_modules`文件夹下面创建一个`symlink`\n* Linux: `ln -nsf node_modules app`\n* Windows: `mklink /D app node_modules`\n***（叉烧包注释：如果你在应用的目录下，应该使用，以bash为例`cd node_modules && ln -nsf [模块路径]`，耍的时候请把app换成你要复制的模块的路径）***\n\n然后你就可以\n\n```javascript\nvar Article = require('app/article');\n```\n**小贴士**：由于git不能处理跨平台的symlinks，所以你不能再git repo里面用这样的文件。不过如果你是在克隆后、git-hook或者是由开发人员手动创建一个symlink，那就没啥问题\n\n另外，你可以\b在npm里面里面增加一条postinstall钩子,这个方法由[scharf](https://gist.github.com/branneman/8048520#comment-1412502)提出。可以把命令加进`package.json`里面\n\n```json\n\"scripts\": {\n    \"postinstall\" : \"node -e \\\"var s='../src',d='node_modules/src',fs=require('fs');fs.exists(d,function(e){e||fs.symlinkSync(s,d,'dir')});\\\"\"\n  }\n```\n\n***（叉烧包注释：`postinstall`会在`npm run install`前先自动执行）***\n\n## 2. 全局变量\n在你的app里面增加\n```javascript\nglobal.__base = __dirname + '/';\n```\n这样你就可以这样用了\n```javascript\nvar Article = require(__base + 'app/models/article');\n```\n\n## 3. 使用\b别人开发的库\n（这里下面再做推荐）\n\n## 4. 环境变量\n设置环境变量`NODE_PATH`成一个指向你app想用的模块的路径（作者的情况下是.）。\n***(叉烧包注释：最好是使用绝对路径，这样比较稳妥)***\n\n然后就可以\n\n```javascript\nvar Article = require('app/models/article');\n```\n\n### 4.1 提前设置\n在启动app前线确保已经设置好了环境变量\n* Linux: `export NODE_PATH=.`\n* Windows: `set NODE_PATH=.`\n使用`export`和`set`是仅对当前shell有效的，如果你需要让他全局、永久的改变，需要修改你的配置文件\n\n### 4.2 只在执行node时设置\n这个\b方法不会影响你的环境，除非node运行。他需要你改变应用启用命令。\n\n像这样启动你的app\n* Linux: `NODE_PATH=. node app`\n* Windows: `cmd.exe /C \"set NODE_PATH=.&& node app\"`\n（在win下面如果你在path和&&之间加空格的话就启动不了\b）\n***（叉烧包注释：这里推荐一下[cross-env](https://www.npmjs.com/package/cross-env)插件，可以跨平台使用命令，这样的话就可以用这样使用命令啦~ `cross-env NODE_PATH=. node app.js`）***\n\n## 5. 启用脚本\n其实和4.2差不多<br>\n其实就是写成一个脚本来运行，不过这样比较方便加各种参数\b\n\n例：\n* Linux: `./app` (Windows PowerShell可)\n* Windows: `app`\n\n### 5.1 Node.js\n\b看[这里](https://gist.github.com/branneman/8775568)\n代码具体是这样\n{% blockquote branneman https://gist.github.com/branneman/8775568 %}\n\n{% codeblock lang:javascript %}\n#!/usr/bin/env node\n\n'use strict';\nhquote\nvar spawn = require('child_process').spawn;\n\nvar args = [\n  '--harmony',\n  'app/bootstrap.js'\n];\n\nvar opt = {\n  cwd: __dirname,\n  env: (function() {\n    process.env.NODE_PATH = '.'; // Enables require() calls relative to the cwd :)\n    //叉烧包注释： 如果需要多个路径可以这样(需要额外 require path 模块)\n    //process.env.NODE_PATH = ['.', './lib'].join(path. delimiter)\n    return process.env;\n  }()),\n  stdio: [process.stdin, process.stdout, process.stderr]\n};\n\nvar app = spawn(process.execPath, args, opt);\nRaw\n{% endcodeblock %}\n\n{% endblockquote %}\n\n### 5.2 操作系统特定的启动脚本\n* Linux\n可以创建一个app.sh    \n\n```bash\n#!/bin/sh\nNODE_PATH=. node app.js\n```\n\n* Windows\n可以创建一个app.bat\n\n```bat\n@echo off\ncmd.exe /C \"set NODE_PATH=.&& node app.js\"\n```\n\n# 6. Hack\n谢谢[@joelabair](https://github.com/joelabair)和4.2差不多，但不需要在app之外指定NODE_PATH。\b但是，由于这依赖于一个专用的Node.js核心方法。╮(╯_╰)╭\n\n你需要在`require`之前运行这个方法。\n```javascript\nprocess.env.NODE_PATH = __dirname;\nrequire('module').Module._initPaths();\n```\n\n# 7. 包裹\n感谢[@a-ignatov-parc](https://github.com/a-ignatov-parc)\n简单来说你可以在你的app最开始运行这样的代码。\n```javascript\nglobal.rootRequire = function(name) {\n    return require(__dirname + '/' + name);\n}\n```\n然后就可以这样\n```javascript\nvar Article = rootRequire('app/models/article');\n```\n\n# 叉烧包总结\n基于我的原则一向来就是越快越好，打字越少越好，所以个人认为\n\n* symlink的方式\b由于各种限制而且你增加一点你的包就得新生产一个，感觉比较的不爽 => pass\n* 增加全局变量，但是还需要自己拼接一下，难受 => pass\n* 环境变量，我比较能接受写一份脚本的方法 0-0\n* \bHack方法，这个我比较的喜欢, 使用时也和原生一样 \n* 包裹方法在require时比较难受，我喜欢能直接`require`…so => pass\n\n# 包子的方法\n## 1. 修改启用命令\n这个上面也提到过4和5中也提到过。<br>\n在启用时这样操作`NODE_PATH=. node app.js`。<br>\n不过得考虑到不同操作系统下面path分割符的问题，所以个人推荐是采用5.1中的方法，写一份node脚本\n\n## 2. HACK\n\b\b我hack了`_findPath()`方法，这个就是想设成啥别名就啥别名\bw，只不过只能兼容\b到node6\n具体可以看[这里](https://github.com/EleanorMao/require-alias/blob/master/index.js)\n\n# 其他人的方法\n* hack了`require`方法，这个和我想的hack差不多，但是\b这样兼容性比较好。[code看这里](https://github.com/sultan99/sexy-require/blob/master/index.js)。这个作者也封装成了一个插件，大家可以去支持一下[sexy-require](https://www.npmjs.com/package/sexy-require)。这边的别名是配置在`package.json`下面的\n\n* 还有hack了`export`方法的，通过`Object.defineProperty`，在get方法时给模块的添加必要的属性\n\n* [babel-plugin-resolver](https://github.com/jshanson7/babel-plugin-resolver)。这个本包倒是没有细去了解，所以使用的小伙伴可以自己看一下\n\n# 插件推荐\n各位有用过别的欢迎在评论里面告诉我哟~(@^_^@)~\n\n## 使用起来和原生没有差别的\n* 先羞羞的安利一下自己的插件[`node-require-alias`](https://www.npmjs.com/package/node-require-alias), node6.0环境以上的考虑一下\n* 还有是通过读`package.json`配置的[sexy-require](https://www.npmjs.com/package/sexy-require)\n* [module-alias](https://www.npmjs.com/package/module-alias)这个读`package.json`和通过方法都可以设置别名\n\n## 使用起来和原生有差别的\n因为我个人比较嫌弃这种写法，这里就不做介绍了，只做推荐\n\n* [require-alias](https://www.npmjs.com/package/require-alias)\n* [app-module-path](https://www.npmjs.com/package/app-module-path)\n\n\n# 最后的总结\n我个人比较的作，喜欢自己写还是比较喜欢HACK！不过我觉得加环境变量也很快，也不用管兼容b(￣▽￣)d。<br>\n另外对于HACK方法我还做了十分随性的原理解析，大家想看的可以戳{% post_link alias-require-hack hack原理解析这篇%}\n","tags":["javascript","node","翻译"]},{"title":"关于inline-block和line-height","url":"/2017/08/29/line-height-inline-block-layout/","content":"# 前言\n最近在看关于inline-block布局产生间隙的原因，顺下去就慢慢看到line-height相关的东西，下面就整理了一下看的东西\n\n# 整理\n## line-height\n* `line-height`设置为百分比或明确的像素(如100%或20px)，行高会被继承下来，继承的是计算值，与之后设置的字号无关(如body设置了font-size:12px,line-height:200%，则继承的行高都是24px)\n* `line-height`设置为数字时候(如1.2)时，行高会与根据之后的字号计算\n* （`line-height`-`font-size`)/2 这段距离被称为半行间距\n* 基线，指的是一行字横排时下沿的基础线，基线并不是汉字的下端沿，而是英文字母x的下端沿\n* 行高具有垂直居中的特性\n\n### boxes？？\n* 行内元素会生成一个行内框(inline box)，没有特别标签的叫匿名inline box\n* 一行的又叫行框(line box)，以一行里面最高的inline box为准\n* 内容区(content area)，有时inline box会小于content area，如果line-height小于font-size，那inline-box会优于行高\n\n### 参考资料\n* [行号：line-height属性1](http://www.ddcat.net/blog/?p=227)\n* [行号：line-height属性2——行高的计算与继承](http://www.ddcat.net/blog/?p=228)\n* [行号：line-height属性3](http://www.ddcat.net/blog/?p=232)\n* [深入了解css的行高Line Height属性](http://www.cnblogs.com/fengzheng126/archive/2012/05/18/2507632.html)\n* [css行高line-height的一些深入理解及应用](http://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/)\n\n## inline-block layout\n* inline-block布局的空格产生于标签(HTML)间的空格(写的时候换行有关)，使用letter-space或margin负值会因为不同浏览器和字体间的不同间隙不一样所以最好别用，可以用letter-spacing:-3px;font-size:0来处理\n* inline-block布局不会和float一样错来错去是因为line box的关系\n\n### 参考资料\n* [去除inline-block元素间间距的N种方法](http://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/)\n* [拜拜了,浮动布局-基于display:inline-block的列表布局](http://www.zhangxinxu.com/wordpress/2010/11/%E6%8B%9C%E6%8B%9C%E4%BA%86%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80-%E5%9F%BA%E4%BA%8Edisplayinline-block%E7%9A%84%E5%88%97%E8%A1%A8%E5%B8%83%E5%B1%80/)\n\n","tags":["diary","css"]},{"title":"八月问题单总结","url":"/2017/08/28/bug-summary-in-august/","content":"最近都没在更博_(:з」∠)_ 但是来总结一下这段时间（我还记得的）发生过的问题\n\n# throw errnoException(err, 'spawn'); Error: spawn EACCES\n这是有个项目一直只在公司的win上面开发，虽然是用git管理的，但是最近一次有急需才clone到mac上来继续开发，\n然后打包项目的时候就遇到了这个报错。<br>\n总之，发现其实是权限的问题，<br>\n**解决方案**<br>\n在项目的root路劲下跑一下这个，把权限调整好就可以了\n```\nchmod -R u+x .\n```\n# HTTP code 206 Partial Content \n是的，那是一天的半夜……，后端的小组长跑来被自动化测试要求发环境，结果发了几次都是挂的，<br>\n然后跑来问我是怎么回事。<br>\n虽然乍一看静态资源是`200`了，但是仔细一看其实是`206`。<br>\n然后仔细一看资源的`Content-Type`是1，然后居然有了个`Content-Range`，而且数字是个很微妙的东西<br>\n{% asset_img content-range.jpg Content-Range %}\n顺便一提↓<br>\n{% blockquote  MDN web docs  https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range  Content-Range%}\nContent-Range 显示的是一个数据片段在整个文件中的位置。\n{% codeblock Content-Range https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range MDN web docs %}\nContent-Range: <unit> <range-start>-<range-end>/<size>\nContent-Range: <unit> <range-start>-<range-end>/*\nContent-Range: <unit> */<size>\n{% endcodeblock %}\n{% endblockquote %}\n而且控制台静态资源报错`ERR_CONTENT_LENGTH_MISMATCH`\n然后在[Stack Overflow](https://stackoverflow.com/search?q=ERR_CONTENT_LENGTH_MISMATCH)上搜了一波，好多人说是nginx的权限问题。<br>\n不过最后一查，是因为磁盘满了=。=\n\n# try-catch\n还有一个是因为最外层的try-catch把error都catch住了，导致报错没有被发现，造成了一个线上bug<br>\n不过我还蛮佩服我自己的，因为这么写已经大半年了，这个缘故的bug还是第一次……原来我都一直没有写出过bug呜呜呜呜<br>\n总之来说是这样的，在外层渲染dom的时候用了这样一段代码<br>\n{% codeblock lang:javascript %}\ntry {\n    ReactDOM.render(<Foo />, document.querySelector('.root'))\n}catch(e){}\n{% endcodeblock %}\n结果我在Foo这个类里面调用了一个某引入组件没有的方法，这个error就被catch……我还找了好久为啥都不报错=L=<br>\n不过小钻风说把source里面的`Pause on exceptions`打开就可以抓住这种奇奇怪怪的bug了\n\n# 微信里的transitionEnd事件\n在微信里面调用了`transitionEnd`事件，但是ios8里面并没有被触发。<br>\n最后谷歌之后，发现说是因为只有`transition-property`是all的时候才能一定出发`transitionEnd`事件……<br>\n吐血<br>\n我确实`transition-property`写的是opacity，为了兼容只能忍辱负重了……抹眼泪<br>\n\n# 微信定位\n这又是一个神坑 =L=<br>\n产品发现部分手机微信定位会蜜汁失败，然后跑来找我们，不过并没有说是什么环境，只有个小视频……而且小视频最后还被删掉了(吐血)<br>\n结果最后又变成在盲找bug<br>\n先说我们的流程，就是先由后端获取定位，如果500的话，再调用JS-SDK定位，如果再没有位置或失败的话就告诉用户定位失败了。<br>\n已知的可能定位失败就是安卓如果在公众号内没有停留超过5s的话就会定位不到，因为微信定位5s推送一次，还有就是关掉或打开定位不会马上定位失败/成功，必须经过一段时间（目测是有缓存）<br>\n然后我们架构师就表示怎么可能定不到位……非要叫我们搞定，心塞的要死😑最后是能一种种试过去<br>\n经过各种试验，可以确定ios关了定位肯定就定不到了，安卓开了定位也有可能订不到，但是关了调用`navigator.geolocation`还能定到，完了这个定位看网络情况可能要好久才能定位到<br>\n过程略，总之最后就是决定改成后端定位返回附近地址和最近收货地址，然后如果没有附近地址就先JS-SDK定位，如果失败再调用`navigator.geolocation`，如果也失败的话再使用收货地址，如果再没有再提示没有。\n\n","tags":["javascript","HTTP"]},{"title":"display、position和float的关系","url":"/2017/07/31/relationship-between-display-position-float/","content":"【翻译自[W3C](https://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo)】\n\n`display`，`positon`和`float`这三个属性都会影响盒子模型和布局，\n他们的关系影响如下：\n\n* 如果`display`的值设为`none`，那么`position`和`float`不会被应用。这种情况下，元素不会生成盒子。\n* 如果`position`如果值设为`absolute`或`fixed`，被定位后的盒子会将`float`计算为`none`，display会按照下表表现。\n  如果该盒子定义了`top`、`right`、`bottom`和`left`属性，那么该盒子则是块级的。\n* 如果`float`定义为`none`以外的值，那么这个盒子的`display`则如下表表现。\n* 如果该元素是根元素，`display`则如下表表现。除了在CSS2.1中因`list-item`会被计算为`block`还是`list-item`是未定义的。\n* 其余`display`属性会按所指定属性表现。\n\n| 属性 | 计算为|\n| ---- | ---- |\n| inline-table | table |\n| inline, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row, table-cell, table-caption, inline-block | block |\n| others| 如所设置的 |","tags":["html","css"]},{"title":"解决input[type=file]打开时慢、卡顿问题","url":"/2017/07/28/input-file-stutter-on-webkit/","content":"\n昨天临下班测试给我问我为什么图片上传插件打开文件夹的速度这么慢，让我想办法优化一下\n然后我就努力的搞了起来_(:з」∠)_\n\n由于我们内部系统不兼容ie，所以我就没有管ie，在浏览器里面玩了起来\n\n经过测试发现，在mac里面safari、Firefox、Chrome(opera不知道为啥老闪退)都没有卡顿问题\n\n在windows里面，Firefox不卡顿，只有Chrome卡顿。\n\n然而，这个插件是从另一个项目里面借用过来，再加上了限定图片类型的功能而已。\n原组件并没有这个卡顿问题，那么问题只可能是在限定图片类型这点上了。\n\n先贴上我的代码\n```javascript\n<input\n    accpet=\"image/*\"\n    style={inputStyle}\n    ref={c=> this._imgFile = c}\n    onChange={this.handleChange.bind(this)}\n    type=\"file\" name=\"image\" disabled={disabled}\n/>\n```\n于是我决定先去掉`accpet`试试……\n果然就没有了卡顿的问题。\n那么本包在试试`accpet=\"image/jpg\"`果然也不卡卡的了！！\n看来问题的所在就是`\"image/*\"`\n\n但是写`accpet`的原意是要想要筛选出所有图片_(:з」∠)_\n那么为了实现这个需求，同时提高用户体验，只能采取枚举了\n\n修改后的代码\n```javascript\n<input\n    style={inputStyle}\n    ref={c=> this._imgFile = c}\n    onChange={this.handleChange.bind(this)}\n    type=\"file\" name=\"image\" disabled={disabled}\n    accpet=\"image/gif,image/png,image/jpeg,image/jpg,image/bmp\"\n/>\n```\n再试试，果然妥妥的了！\n\n但是到底是为什么会这么卡呢？？我查了查万能的Stack Overflow→_→\n\n原来是因为Chrome的{% link SafeBrowsing http://safebrowsing.google.com/  SafeBrowsing %}功能会在上传或保存时检查文件，\n如果网络连接到google的速度比较快呢，就没有什么问题。\n但是如果连接比较慢，或者干脆跪掉了，那SafeBrowsing就会让Chrome挂起一段时间，直到文件检查结束或者超时\n\n使用`accept=\"image/png, image/jpeg, image/gif\"`就可以解决这个问题，因为这些MIME类型在SafeBrowsing的白名单里面，不需要检查。\n但是如果用像是`accept=\"image/*\"`这样的呢，就不行了，就有可能变得卡卡的。\n\n\n","tags":["html","优化"]},{"title":"WEB缓存探究第三弹——为什么关闭ETag","url":"/2017/07/28/web-cache-develop-3/","content":"## 前言\n在{% post_link web-cache-explore 前面的文章%}里我们已经知道了ETag作为文件的指纹，\n在浏览器缓存中发挥着重要作用。但今天我们就来说说为什么有时要关闭Etag。\n\n## WHY？\n以Apache为例，它其中中内建的ETag机制是用inode、文档大小和最后修改时间来产生的。\n{% blockquote 阮一峰 http://www.ruanyifeng.com/blog/2011/12/inode.html 理解inode %}\n**什么是inode？**\ninode就是`索引节点`。\ninode包含文件的元信息，具体来说有以下内容：\n* 文件的字节数\n* 文件拥有者的User ID\n* 文件的Group ID\n* 文件的读、写、执行权限\n* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。\n* 链接数，即有多少文件名指向这个inode\n* 文件数据block的位置\n{% endblockquote %}\n\n### 会带来什么影响\n这导致在分布式下不同机器可能会产生不同的inode，那会让每台机子上生成的ETag都有可能不同，\n那么Etag反而失去了原来的意义，反过来让每次请求都可能去重新下载一次资源啦\n\n## HOW\n如果是分布式，使用ETag先了解好如何产生的，充分测试，来决定要不要关闭ETag。\n当然也可以完全不用ETag，依靠cache-control来控制缓存更新时间。\n","tags":["javascript","HTTP","前端优化","缓存"]},{"title":"WEB缓存探究第二弹——实战","url":"/2017/07/27/web-cache-develop-2/","content":"\n## 前言\n{% post_link web-cache-explore WEB缓存探究第一弹%}中我们讲了一些WEB缓存的基础知识和策略。\n第二弹我们来讲讲如何实际在项目中配置。\n\n## 实战\n鉴于叉烧包本包是个前端，所以我们就以HTML和Node为例开始{% asset_img heywego.jpg hey-we-go %}\n\n### HTML——在header中加入meta标签\n***当然根据我的测试发现这种方式好像并没有什么卵用***\n这段代码代表的是不需要浏览器缓存\n```html\n<header>\n    <meta http-equiv=\"Cache-Control\" content=\"no-cache\" /> <!-- HTTP 1.1 -->\n    <meta http-equiv=\"Pragma\" content=\"no-cache\" /> <!-- 兼容HTTP1.0 -->\n    <meta http-equiv=\"Expires\" content=\"0\" /> <!-- 资源到期时间设为0 -->\n</header>\n```\n\n### Node.js——Express\n鉴于Express2.x和3.x已经是deprecated，所以此处以Express4.x为例。\n#### HTML\n在{% post_link web-cache-explore WEB缓存探究第一弹%}定制缓存策略中已经提到对于HTML最好标记为不缓存，以便及时获取最新的静态资源版本。\n通常我们在Express中渲染HTML会用到以下类似的代码👇\n``` javascript res.render http://expressjs.com/en/4x/api.html#res.render Express\n//当访问/index时，渲染模板index到页面\nrouter.get('index', (req, res)=>{\n    res.render('index');\n});\n```\n\n在这时我们可以使用`{% link res.set(field[,value]) http://expressjs.com/en/4x/api.html#res.set  res.set(field[,value]) %}`或者它的别名`res.header(field [, value])`为HTML设置Header。\n此时代码如下：\n``` javascript res.set http://expressjs.com/en/4x/api.html#res.set Express\nrouter.get('index', (req, res)=>{\n    res.set('Cache-Control', 'no-cache;max-age:0').render('index');\n    /*\n        或者  res.header('Cache-Control', 'no-cache;max-age:0').render('index');\n        或者  res.set({'Cache-Control':'no-cache', 'max-age':0}).render('index');\n    */\n});\n```\n也可以使用中间件的方式批量为请求加上需要的头：\n```javascript\napp.use((req, res, next) => {\n  res.set('Cache-Control', 'no-cache;max-age:0');\n  next();\n})\n```\n效果如下：\n{% asset_img express1.png Express %}\n\n不过细心的小伙伴应该已经发现了，\n{% asset_img express2.png Express %}\n没错机智的Express已经为我们加上了`ETag`😂\n\n让我们来复习一下第一弹的知识点，`Etag`资源的验证令牌，如果指纹变化请求时则会重新下载资源，否则则不会。\n\n可能有的人就问了，那我还需要给HTML加上`Cache-Control`吗？\n\n当然仅用`ETag`来控制资源是否缓存和更新是合理的，不过我的意见是，如果明确不缓存该资源，最好还是要加上`Cache-Control`。\n\n#### 静态资源\nExpress发布静态资源通过的是`{% link express.static(root, [options]) http://expressjs.com/en/4x/api.html#express.static %}`方法。\n```javascript\napp.use(express.static(path.join(__dirname, 'public')));\n```\n它的options参数可以配置header参数\n{% asset_img express3.png Express %}\n静态资源我们最好是为他加上一个超长的过期时间，像这样\n```javascript express.static http://expressjs.com/en/4x/api.html#express.static Express\n//作为Exprss参数的maxAge的单位是毫秒，但是在header中单位是秒！不要搞错哦\napp.use(express.static(path.join(__dirname, 'public'), {\n  maxAge: 3153600000,\n  setHeaders: (res, path, stat) => {\n    res.set({'Expires': new Date('2100-12-12')})\n  }\n}));\n//如果需要分别为资源设置头，可以使用多个`express.static`管理\n//或者在`setHeaders`函数中通过判断`path`后缀分别加上不同的头\n//当然有更靠谱的方法欢迎联系我 >w< \n```\n效果如下：\n{% asset_img express4.png Express %}\n\n**不过不要忘记给静态资源文件名加上指纹哦**\n\n\n### Nginx\n\n同理，就不在重复叙述了，只写一下配置\n\n不过同时设置`expires`和`add_header Cache-Control`会在请求中出现复数的`Cache-Control`，但HTTP1.1能够识别它。\n```nginx\nlocation ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ {\n    etag off;   #关闭etag\n    expires 1d; #有效期一天 \n    # expires的单位可以使用\n    # ms: 毫秒\n    #  s: 秒\n    #  m: 分钟\n    #  h: 小时\n    #  d: 天\n    #  w: 星期\n    #  M: 月 (30 天)\n    #  y: 年 (365 天)\n}\n\nlocation ~ .*\\.css$ {\n    expires 1y; #有效期一年\n    add_header Cache-Control public; #cache-control设为public\n}\n\n\nlocation ~ .*\\.js$ {\n    expires 1y; #有效期一年\n    add_header Cache-Control private; #cache-control设为private\n}\n```","tags":["javascript","HTTP","前端优化","缓存"]},{"title":"WEB缓存探究","url":"/2017/07/26/web-cache-explore/","content":"\n## 前言\n由于项目越来越大，即使了使用代码压缩工具减少文件大小，js文件还是不可避免的越变越大。\n而对于用户来说每次重新下载都有可能会消耗大量时间，让我们的首屏展示有较长时间的空白。\n为了提升网站性能，有效利用缓存能够提升用户体验，提高访问效率。\n\n## 浏览器缓存\n### HTML中的Meta标签\nhttp-equiv属性，相当于http的文件头中的参数，而content的内容则是对应参数的值\n```html\n<!-- 告诉浏览器不缓存当前页面 -->\n<meta http-equiv=\"pragma\" content=\"no-cache\">\n```\n然而设置`pragma: no-cache`并不能应用于HTTP1.1及以上规范，\n而且因为这个方法太老了，如果你不需要估计那些史前客户的感受，完全可以不加👆\n\n当然可以不用太方，还有其他的参数可以选择使用\n```html\n<meta http-equiv=\"Cache-Control\" content=\"no-cache\" /> <!-- HTTP1.1 在1.1中优先于expires-->\n<meta http-equiv=\"pragma\" content=\"no-cache\" /> <!-- HTTP1.0 -->\n<meta http-equiv=\"Expires\" content=\"0\" /> <!-- 示意到期时间 HTTP1.0 & 1.1 -->\n```\n\n但是使用meta标签设置的参数优先级低于http请求中声明的，如果你同时设置了http头，那么就没有必要加上meta标签了。\n\n**当然，最后还有一个重要的一点，就是根据叉烧包的实验，meta制定这些内容可以说基本没有什么卵用:)**\n**悲伤的故事……当然可能你的浏览器还可以用哦**\n\n### Header参数\n最保险的显然是配置Header参数来保证资源的缓存\n\n1. **Cache-Control**\n    Cache-Control 标头是在 HTTP/1.1 规范中定义的，取代了之前用来定义响应缓存策略的标头例如 Expires。\n    所有现代浏览器都支持 Cache-Control。\n    * **max-age**     指从请求的时间开始，允许缓存有效的最长时间(单位是s)\n    * **public**      无条件缓存。它不是必须的，因为明确的缓存信息已表示响应是可以缓存的\n    * **private**     通常只为单个用户缓存，不允许任何中间缓存对其进行缓存\n    * **no-cache**    表示必须先与服务器确认返回的响应是否发生了变化。\n    * **no-store**    禁止浏览器以及所有中间缓存存储任何版本的返回响应，每次请求必须重新下载\n\n    借用谷歌爸爸的一张图来展示一下Cache-Control的选择策略\n    {% asset_img http-cache-decision-tree.png 最佳Cache-Control策略树 %}\n2. **Expires**\n   它代表一个缓存过期的绝对时间，在HTTP/1.0中实现，在HTTP/1.1中优先级低于Cache-Control。\n   它的缺点就是如果服务器与客户端误差较大，那么它的误差也会变大\n3. **Last-Modified**\n   标记的是资源的最后修改时间，需要配合Cache-Control使用。只能精确到秒级，如果某些文件在1秒内修改多次，则无法及时更新\n4. **ETag**\n   相当于验证令牌。通过它可以可实现高效的资源更新检查：资源未发生变化时不会传送任何数据。\n   ETag通常是服务器生成的文件内容的哈希值或某个其他指纹。如果请求时指纹仍然相同，则表示资源未发生变化，则可跳过下载。\n\n#### 参数弃用小指南\n* 如果你不考虑ie6和`HTTP 1.0`客户端，那么你可以无视`Pragma`\n```http\nCache-Control: no-store, must-revalidate\nExpires: 0\n```\n* 如果你也不打算管`HTTP 1.0`代理，那么你可以无视`Expires`\n```http\nCache-Control: no-store, must-revalidate\n```\n* 如果服务器自动包含有效的`Date`标头，则理论上也可以省略`Cache-Control`，并仅依赖于`Expires`。不过如果客户端和服务端时间有差别，就可能会失败哦\n```http\nDate: Wed, 24 Aug 2016 18:32:02 GMT\nExpires: 0\n```\n* 总的来说还是使用`Cache-Control`最妥妥的(如果不打算考虑`HTTP 1.0`)\n\n## 项目实践\n### 更新文件&弃用缓存\n在项目中，当我们使用本地缓存后又会遇到另一个问题——如何更新文件、弃用缓存。\n通常，我们通过对文件名加入指纹来实现。\n\n以webpack为例，\n写配置文件时\n```javascript\n{\n    output: {\n        filename: \"bundle.[hash].js\"\n    }\n}\n```\n为打包后的文件名加上hash，使文件更新之后会生成新的hash，以达到弃用原来缓存的效果。\n\n### 定制缓存策略\n可以为不同类型的文件定义不同的缓存策略，以达到最高效的结果\n1. 将HTML被标记为“no-cache”，使浏览器在每次请求时都始终会重新验证文档，并在内容变化时能够及时获取最新版本，即使下载新资源。\n2. 允许浏览器和中间缓存（如CDN）缓存CSS，并将CSS设置为1年后到期，超长的缓存时间可以让用户避免每次都从服务端获取响应。同时不要忘记给文件名加上指纹，以便及时更新改动\n3. JavaScript同样设置为1年后到期，但标记为private，因为它可能会包含某些用户私人数据，这是CDN不应缓存的。\n4. 图像缓存时不包含版本或唯一指纹，并设置为1天后到期。\n\n### 其他技巧\n1. 减少对Cookie的依赖，因为每次HTTP请求都会带上Cookie，这回增大传输流量（当然将静态资源挂载在其他域名下，也可以达到cookie free的效果）\n\n","tags":["javascript","HTTP","前端优化","缓存"]},{"title":"空虚寂寞冷","url":"/2017/07/21/2017-07-21/","content":"\n测试的专业都比我对口\n\nSAD\n\n大概他前端学会的那天找工作比我好找吧╮(╯_╰)╭\n\n大家都去吃饭了，不然那就下班了，就剩我了\n\n## 空虚寂寞冷_(:з」∠)_\n\n","tags":["diary"]},{"title":"JavaScript高级程序设计里的functions","url":"/2017/07/17/js-in-professional-javascript-for-web-developers/","content":"因为比较无聊，然后本包包又是个比较喜欢做笔记的人\n\n整理了一下JavaScript高级程序设计里面出现过的function并标了注释\n\n大抵摘自第9章自第14章\n\n\n\n\n{% asset_img syobo.jpg 魔力小包包 %}\n\n\n\n话说昨天睡前喝了几口咖啡一直亢奋到现在\n\n而且就一直梦见炒黄豆炒了一晚上QAQ\n\n\n```javascript\n//代码整理♪(^∇^*)啦啦 客户端检查\nvar client = function () {\n    var engine = {\n        ie: 0,\n        gecko: 0,\n        webkit: 0,\n        khtml: 0,\n        opera: 0,\n        ver: null\n    }\n    var browser = {\n        ie: 0,\n        firefox: 0,\n        safari: 0,\n        konq: 0,\n        opera: 0,\n        chrome: 0,\n        ver: null\n    }\n    var system = {\n        win: false,\n        mac: false,\n        x11: false,\n        iphone: false,\n        ipod: false,\n        ipad: false,\n        ios: false,\n        android: false,\n        nokiaN: false,\n        winMobile: false,\n        wii: false,\n        ps: false\n    }\n    var ua = navigator.userAgent;\n    /*\n    * opera 5及更高版本中都有opera对象，用于保存浏览器相关的表示信息等 opera\n    * 7.6及更高版本中，需要调用version()方法以返回一个表示浏览器版本的字符串\n    */\n    if (window.opera) {\n        engine.ver = browser.ver = window\n            .opera\n            .version();\n        engine.opera = browser.opera = parseFloat(engine.ver);\n    } else if (/AppleWebKit\\/(\\S+)/.test(ua)) {\n        engine.ver = RegExp[\"$1\"];\n        engine.webkit = parseFloat(engine.ver);\n        //确定safari还是chrome\n        if (/Chrome\\/(\\S+)/.test(ua)) {\n            /*\n        * chrome版本号信息格式\n        * Mozilla/5.0 (平台;加密类型;操作系统或CPU;语言)\n        * AppleWebKit/AppleWebKit版本号 (KHTML, like Gecko) Chrome/Chrome版本号 Safari/Safari版本\n        * 实例：Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\n        */\n            browser.ver = RegExp[\"$1\"];\n            browser.chrome = parseFloat(browser.ver);\n        } else if (/Version\\/(\\S+)/.test(ua)) {\n            /*\n        * safari版本号信息格式(3及以后)\n        * Mozilla/5.0 (平台;加密类型;操作系统或CPU;语言)\n        * AppleWebKit/AppleWebKit版本号 (KHTML, like Gecko) Version/Safari实际版本号  Safari/Safari版本号\n        * 实例：Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/603.2.4 (KHTML, like Gecko) Version/10.1.1 Safari/603.2.4\n        */\n            browser.ver = RegExp[\"$1\"];\n            browser.safari = parseFloat(browser.ver);\n        } else {\n            //确定相近版本号\n            var safariVersion = 1;\n            if (engine.webkit < 100) {\n                safariVersion = 1;\n            } else if (engine.webkit < 312) {\n                safariVersion = 1.2;\n            } else if (engine.webkit < 412) {\n                safariVersion = 1.3;\n            } else {\n                safariVersion = 2;\n            }\n            browser.safari = browser.ver = safariVersion;\n        }\n    } else if (/KHTML\\/(\\S+)/.test(ua) || /Konqueror\\/([^;]+)/.test(ua)) {\n        /*\n        * Konqueror版本信息格式\n        * Mozilla/5.0 (compatible; Konqueror/版本号;操作系统或CPU)\n        * konqueror 3.2之后\n        * Mozilla/5.0 (compatible; Konqueror/版本号;操作系统或CPU) KHTML/KHTML 版 本号 (like Gecko)\n        */\n        engine.ver = browser.ver = RegExp[\"$1\"];\n        engine.khtml = browser.konq = parseFloat(engine.ver);\n    } else if (/rv:([^\\)]+)\\) Gecko\\/\\d{8}/.test(ua)) {\n        /*\n        * Gecko版本信息格式\n        * Mozilla/Mozilla版本号 (平台;加密类型;操作系统或CPU;语言;预先发行版本)\n        * Gecko/Gecko版本号 应用程序或产品/应用程序或产品版本号\n        * 实例(火狐)：Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:47.0) Gecko/20100101 Firefox/47.0\n        */\n        engine.ver = RegExp[\"$1\"];\n        engine.gecko = parseFloat(engine.ver);\n        //确定是不是Firefox\n        if (/Firefox\\/(\\S+)/.test(ua)) {\n            browser.ver = RegExp[\"$1\"];\n            browser.firefox = parseFloat(browser.ver);\n        }\n    } else if (/MSIE ([^;]+)/.test(ua)) {\n        //ie\n        engine.ver = browser.ver = RegExp[\"$ 1\"];\n        engine.ie = browser.ie = parseFloat(engine.ver);\n    }\n\n    //监测浏览器\n    browser.ie = engine.ie;\n    browser.opera = engine.opera;\n\n    //监测平台\n    var p = navigator.platform;\n    system.win = p.indexOf('Win') == 0;\n    system.mac = p.indexOf('Mac') == 0;\n    system.x11 = (p == \"X11\") || (p.indexOf(\"Linux\") == 0);\n\n    //检查Windows的操作系统\n    if (system.win) {\n        /*\n        * 匹配Windows95和Windows98这两个字符串。对这两个字符串，只有Gecko与其他浏览器不同，\n        * 即没有\"dows\"，而且\"Win\"与版本号之间没有空格 <- Win95和Win98\n        * Gecko在表示Windows NT时会在末尾添加\"4.0\"，因此在最后匹配一下小数\n        */\n        if (/Win(?:dows )?([^do]{2}) \\s?(\\d+\\.\\d+)?/.test(ua)) {\n            if (RegExp[\"$1\"] === \"NT\") {\n                switch (RegExp[\"$2\"]) {\n                    case \"5.0\":\n                        system.win = \"2000\";\n                        break;\n                    case \"5.1\":\n                        system.win = \"XP\";\n                        break;\n                    case \"6.0\":\n                        system.win = \"Vista\";\n                        break;\n                    case \"6.1\":\n                        system.win = \"7\";\n                        break;\n                    default:\n                        system.win = \"NT\";\n                        break;\n                }\n            } else if (RegExp[\"$1\"] === \"9x\") {\n                system.win = \"ME\";\n            } else {\n                system.win = RegExp[\"$1\"];\n            }\n        }\n    }\n    //移动设备\n    system.iphone = ua.indexOf(\"iPhone\") > -1;\n    system.ipad = ua.indexOf(\"iPad\") > -1;\n    system.ipod = ua.indexOf(\"iPod\") > -1;\n    system.nokiaN = ua.indexOf(\"NokiaN\") > -1;\n    //windows mobile\n    if (system.win === \"CE\") {\n        system.winMobile = system.win;\n    } else if (system.win === \"Ph\") {\n        if (/Windows Phone OS (\\d+.\\d+)/.test(ua)) {\n            system.win = \"Phone\";\n            system.winMobile = parseFloat(RegExp[\"$1\"]);\n        }\n    }\n    //监测iOS版本\n    if (system.mac && ua.indexOf(\"Mobile\") > -1) {\n        if (/CPU (?:iPhone)?OS (\\d+_\\d+)/.test(ua)) {\n            system.ios = parseFloat(RegExp[\"$1\"].replace(\"_\", \".\"));\n        } else {\n            system.ios = 2;\n        }\n    }\n    //监测安卓\n    if (/Android (\\d+\\.\\d+)/.test(ua)) {\n        system.android = parseFloat(RegExp[\"$1\"]);\n    }\n    //游戏系统\n    system.wii = ua.indexOf(\"Wii\") > -1;\n    system.ps = /playstation/i.test(ua);\n\n    return {engine, browser, system};\n}()\n\n//NodeList转换为数组\nfunction convertToArray(nodes) {\n    var array = null;\n    try {\n        array = []\n            .slice\n            .call(nodes, 0);\n    } catch (ex) {\n        //ie8及更早版本中NodeList是COM对象，所以需要手动枚举\n        array = [];\n        for (var i = 0; i < nodes.length; i++) {\n            array.push(nodes[i]);\n        }\n    }\n    return array;\n}\n\n//序列化attribute属性\nfunction outputAttributes(element) {\n    var pairs = [],\n        attrName,\n        attrValue,\n        i,\n        len;\n    for (i = 0, len = element.attributes.length; i < len; i++) {\n        attrName = element.attributes[i].nodeName;\n        attrValue = element.attributes[i].nodeValue;\n        if (element.attributes[i].specified) {\n            //ie7的问题(返回一大堆)，因此指定specified，使其返回html中指定的相应特性\n            pairs.push(`${attrName}=${attrValue}`);\n        }\n    }\n    return pairs.join(\" \");\n}\n\n//动态脚本 然而并没有方法知道脚本有米有加载完\nfunction loadScript(url) {\n    var script = document.createElement(\"script\");\n    script.type = \"text/javascript\";\n    script.src = url;\n    document\n        .body\n        .appendChild(script);\n}\n\n//动态样式\nfunction loadStyles(url) {\n    var link = document.createElement(\"link\");\n    link.rel = \"stylesheet\";\n    link.type = \"text/css\";\n    link.href = url;\n    var head = document.getElementsByTagName(\"head\")[0];\n    head.appendChild(link);\n}\n\n//动态插入行内样式\nfunction loadStyleString(css) {\n    var style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    try {\n        style.appendChild(document.createTextNode(css));\n    } catch (ex) {\n        //ie将style视为一个特殊节点，不能直接访问其子节点。重用同一个style元素并重设cssText属性时，可能会导致浏览器崩溃\n        style.styleSheet.cssText = css;\n    }\n    var head = document.getElementsByTagName(\"head\")[0];\n    head.appendChild(style);\n}\n\n//检查元素是否与选择符匹配\nfunction matchesSelector(el, selector) {\n    if (el.matchesSelector) {\n        return el.matchesSelector(selector);\n    } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n    } else if (el.mozMatchesSelector) {\n        return el.mozMatchesSelector(selector);\n    } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n    } else {\n        throw Error('Not Support!');\n    }\n}\n\n//包含\nfunction contains(refNode, otherNode) {\n    if (typeof refNode.contains === \"function\") {\n        //是后代节点则返回true，支持的浏览器有IE、FireFox9+、Safari、Opera和Chrome\n        return refNode.contains(otherNode);\n    } else if (typeof refNode.compareDocumentPosition === \"function\") {\n        //1-无关，2-居前，4-居后，8-包含，16-被包含\n        return !!(refNode.compareDocumentPosition & 16);\n    } else {\n        var node = otherNode.parentNode;\n        while (node !== null) {\n            if (node === refNode) {\n                return true;\n            } else {\n                node = node.parentNode;\n            }\n        }\n        return false;\n    }\n}\n\n//获取样式表\nfunction getStyleSheet(el) {\n    //ie不支持sheet属性\n    return el.sheet || el.styleSheet;\n}\n\n//向样式表插入规则\nfunction insertRule(sheet, selectorText, cssText, position) {\n    if (sheet.insertRule) {\n        //FireFox,Safari,Opera和Chrome支持\n        sheet.insertRule(selectorText + \"(\" + cssText + \")\", position);\n    } else if (sheet.addRule) {\n        //ie8及更早，最多添加4095条样式\n        sheet.addRule(selectorText, cssText, position);\n    }\n}\n\n//删除规则\nfunction deleteRule(sheet, index) {\n    if (sheet.deleteRule) {\n        sheet.deleteRule(index);\n    } else if (sheet.removeRule) {\n        //ie\n        sheet.removeRule(index);\n    }\n}\n\n//获取某元素在页面上的偏移量(左)\nfunction getElementLeft(el) {\n    var actualLeft = el.offsetLeft;\n    var current = el.offsetParent;\n    while (current !== null) {\n        actualLeft += current.offsetLeft;\n        current = current.offsetParent;\n    }\n    return actualLeft;\n}\n\n//获取某元素在页面上的偏移量(上)\nfunction getElementTop(el) {\n    var actualTop = el.offsetTop;\n    var current = el.offsetParent;\n    while (current !== null) {\n        actualTop += current.offsetTop;\n        current = current.offsetParent;\n    }\n    return actualTop;\n}\n\n//获取视窗大小\nfunction getViewport() {\n    //clientWidth-元素内容区宽度+内边距宽度\n    if (document.compatMode === \"BackCompat\") {\n        //ie7及之前\n        return {width: document.body.clientWidth, height: document.body.clientHeight}\n    } else {\n        return {width: document.documentElement.clientWidth, height: document.documentElement.clientHeight}\n    }\n}\n\n//获取元素大小和位置\nfunction getBoundingClientRect(element) {\n    //然而严格模式下不允许使用calleeQAQ;ie8及更早以(2,2)为坐标七点，因此需要检查一下元素的位置\n    var scrollTop = document.body.scrollTop;\n    var scrollLeft = document.body.scrollLeft;\n    if (element.getBoundingClientRect) {\n        if (typeof arguments.callee.offset !== \"number\") {\n            var temp = document.createElement(\"div\");\n            temp.style.cssText = \"position:absolute;left:0;top:0;\";\n            document\n                .body\n                .appendChild(temp);\n            arguments.callee.offset = -temp\n                .getBoundingClientRect()\n                .top - scrollTop;\n            document\n                .body\n                .removeChild(temp);\n            temp = null;\n        }\n        var rect = element.getBoundingClientRect();\n        var offset = arguments.callee.offset;\n\n        return {\n            left: rect.left + offset,\n            right: rect.right + offset,\n            top: rect.top + offset,\n            bottom: rect.bottom + offset\n        }\n    } else {\n        var actualTop = getElementTop(element);\n        var actualLeft = getElementLeft(element);\n        return {\n            left: actualLeft - scrollLeft,\n            right: actualLeft + element.offsetWidth - scrollLeft,\n            top: actualTop - scrollTop,\n            bottom: actualTop + element.offsetHeight - scrollTop\n        }\n    }\n}\n\nvar EventUtil = {\n    addHandler(element, type, handler) {\n        if (element.addEventListener) {\n            //false-冒泡阶段调用，true-捕获阶段调用\n            element.addEventListener(type, handler, false);\n        } else if (element.attachEvent) {\n            element.attachEvent(\"on\" + type, handler);\n        } else {\n            element[\"on\" + type] = handler;\n        }\n    },\n    removeHandler(element, type, handler) {\n        if (element.removeEventListener) {\n            element.removeEventListener(type, handler, false);\n        } else if (element.attachEvent) {\n            element.attachEvent(\"on\" + type, handler)\n        } else {\n            element[\"on\" + type] = null;\n        }\n    },\n    getEvent(e) {\n        //在ie中，event参数是未定义的，因此就会返回window.event\n        return e || window.event;\n    },\n    getTarget(e) {\n        // e.srcElement是e.target的一个别名，只有ie有；load事件target会被设置成document，ie则不会设置scrElement\n        // script标签在ie9+、Safari3+及其他浏览器有onload事件，ie&opera的link有onload事件\n        return e.target || e.srcElement;\n    },\n    preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n        } else {\n            //ie用，不标准，ff没有这个属性\n            e.returnValue = false;\n        }\n    },\n    stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n        } else {\n            e.cancelBubble = true;\n        }\n    },\n    getRelatedTarget(e) {\n        //只有mouseover和mouseout事件才有该值，ie8及之前版本不支持relatedTarget\n        if (e.relatedTarget) {\n            return e.relatedTarget;\n        } else if (e.toElement) {\n            //mouseout事件触发\n            return e.toElement;\n        } else if (e.fromElement) {\n            //mouseover事件触发\n            return e.fromElement;\n        } else {\n            return null;\n        }\n    },\n    getButton(e) {\n        //mousedown&mouseup事件，则在其event时间中存在一个button属性\n        if (document.implementation.hasFeature(\"MouseEvents\", \"2,0\")) {\n            //常规0-主鼠标，1-中间鼠标，2-次鼠标触发\n            return e.button;\n        } else {\n            //ie8及之前\n            switch (e.button) {\n                case 0: //没有按下\n                case 1: //按下主鼠标\n                case 3: //同时按下主次\n                case 5: //按下主和中\n                case 7: //按下三个\n                    return 0;\n                    break;\n                case 2: //按下次鼠标\n                case 6:\n                    return 2;\n                    break;\n                case 4: //按下中间\n                    return 1;\n                    break;\n            }\n        }\n    },\n    getWheelDelta(e) {\n        //mousewheel事件\n        if (e.wheelDelta) {\n            //在opera9.5之前是正负号电脑的，一般是120的倍数\n            return (client.engine.opera && client.engine.opera < 9.5)\n                ? -e.wheelDelta\n                : e.wheelDelta;\n        } else {\n            //ff是3的倍数, 实际看来我用的chrome虽然是放在wheelDelta里面的但是也是3的倍数\n            return -e.detail * 40\n        }\n    },\n    getCharCode(e) {\n        // 代表一个与键盘对应的码\n        // ie9+,ff,chrome,safari在keypress的时候有charCode属性，此时的keyCode可能是0or其他所按键的键码\n        // 因为keypress是按下自附件出发，keydown是按下所有键触发\n        if (typeof e.charCode === \"number\") {\n            return e.charCode\n        } else {\n            return e.keyCode\n        }\n    },\n    getKey(e) {\n        // dom3新增，键盘事件不再包含charCode，而包含key、char属性，key代表按下的字符文本，char在非字符的时候是null\n        // ie9支持key不支持char，safari5&chrome支持keyIdentifier(对于字符键返回表示unicode值)\n        // 因为跨浏览器问题，不推荐（我使用的chrome没有keyIndentifier但又key和char）\n        return e.key || e.char || e.keyIdentifier\n    },\n    getLocation(e) {\n        //0-默认键盘，1-左侧位置，2-右侧位置，3-数字小键盘，4-虚拟键盘，5-手柄\n        return e.location || e.keyLocation;\n    },\n    getClipboardText(e) {\n        var clipboardData = (e.clipboardData || window.clipboardData);\n        //safari和chrome中接受的参数是MIMEtype，不过可以用text代表text/plain\n        return clipboardData.getData(\"text\");\n    },\n    setClipboardText(e, value) {\n        if (e.clipboardData) {\n            return e\n                .clipboardData\n                .setData(\"text/plain\", value);\n        } else if (window.clipboardData) {\n            return window\n                .clipboardData\n                .setData(\"text\", value);\n        }\n    }\n}\n\n//取得选中的文本\nfunction getSelectedText(textbox) {\n    if (typeof textbox.selectionStart === \"number\") {\n        return textbox\n            .value\n            .substring(textbox.selectionStart, textbox.selectionEnd);\n    } else if (document.selection) {\n        //兼容ie8\n        return document\n            .selection\n            .createRange()\n            .text;\n    }\n}\n\n//选择部分文本\nfunction selectText(textbox, startIndex, stopIndex) {\n    if (textbox.setSelectionRange) {\n        //ie9+及其他，要看到选择的文本需要焦点\n        textbox.setSelectionRange(startIndex, stopIndex);\n    } else if (textbox.createTextRange) {\n        //创建范围\n        var range = textbox.createTextRange();\n        //将范围止跌到文本框开始位置\n        range.collapse(true);\n        //移动\n        range.moveStart(\"character\", startIndex);\n        range.moveEnd(\"character\", stopIndex - startIndex);\n        //选择文本\n        range.select();\n    }\n    textbox.focus();\n}\n\n//对于选择多项的选择框，selectedIndex只返回选中项的第一项\nfunction getSelectedOptions(selectbox) {\n    var result = [];\n    var option = null;\n    for (var i = 0, len = selectbox.options.length; i < len; i++) {\n        option = selectbox.options[i];\n        if (option.selected) {\n            result.push(option);\n        }\n    }\n    return result;\n}\n```","tags":["javascript"]},{"title":"2017-06-21","url":"/2017/06/21/2017-06-21/","content":"運がついてくれないかも。本当。\n最近いろんなことできてって…\n\n以後どうなるのかまじでしんぱいしてる、迎えることになる未来も怖いの気がする。\n\nまず一つは、通ってるジムのプライバシートレーナーが突然クビされ、後のトレーナーも決まってないし、\nそしてそれは新しいマネージャーが来て、今のトレーナーは全部自分の人に変えたいらしいだって。\n僕から見れば、このジムも終わるらしいだね、だって会員たちにもこんなこと言えてくれないし、\nそして僕たちは今のトレーナーがいるこそここのジムで通ってるわけよ、もう彼が行ってしまうだら、\n僕もこんな不安定なジムに通いたくないし！\n\n律己。\n\n<!-- 还有就是，这事草甸太大了我决定用中文写\n就是我们组的leader准备要跳槽去橙鹰了，然后就找人接替他嘛，\n按照一般的思路的话，比方说是找组里的老司机接替或者找一个空降一个老司机\n但是我们架构师兼项目经理简直脑洞大开到我怀疑他没有脑子\n\n**他找了一个java让他3天精通前端来当我们leader**\n\n呵呵\n\n简直人神共愤，思路清奇有没有\n\n我也想不通这个java是脑子哪个部分糊上了，好好的java不写，项目也不熟悉，\n说前端就前端呐\n\n极度怀疑不是人缘极差就是技术奇烂\n\n不说了…他已经去7天精通react去了，祝他好运☺\n\n而且我听我们架构师的说法好像是锅给我背，管归他管，我的天？我简直？？？\n\n没毛病🙂\n\n不说了准备暗中观察……观察效果不好我就准备换个坑加班了 -->","tags":["diary"]},{"title":"2017-06-11","url":"/2017/06/11/2017-06-11/","content":"最近都忙些业务好像很久没有写过博客惹呢_(:з」∠)_\n其实差不多买完域名就把没有写过了呢。。。\n然后最近看书也没有做笔记，噗噗\n\n然后这周基本好像都有各种事，健身都没有这么去，在石灰桥和拱宸桥之间住来住去\n对了，其实膝盖被我脱了好几个月了，终于去做了MR，好贵orz！\n而且脑一抽约了个晚上8点45分的orz 还好运气比较好，5点多的有人取消，医生打电话过来叫我提前做\n不过过了太久，膝盖已经好了！耶！\n然后健身就可以开始练腿了，累的我…………晚上饿的要吃夜宵 = = ！所以体重才会一直反复\n\n然后不知不觉又站在了人生的交叉口上了呢_(:з」∠)_\n因为XD问我要不要考浙大的在职研，因为有双证，这样读完就3年经验了，还是硕士\n我好纠结……因为我本科才考了个二本耶……而且还要做外包和健身，会不会完全没时间啊……躺倒\n其实我主要纠结点在于时间啦\n\n然后这周和兔子久违的正常的聊了下天，\n丫要被甩了哈哈哈哈哈哈哈哈哈哈哈！\n然后他说我感觉长大了 \n恩……哦\n\n哎(ノ_・、)\n","tags":["diary"]},{"title":"DOM","url":"/2017/05/23/dom/","content":"\nDOM描绘了一个层次化的节点树，可以将HTML或XML文档描绘成一个由多节点构成的结构。\n\n## 文档节点\n是每个文档的根节点。通常在HTML页面中文档节点只有一个子节点，且始终是`<html>`元素，称之为文档元素。\n文档元素是文档的最外层元素，每个文档只能有一个文档元素。（XML任何元素都可以成为文档元素）\n\n## 节点关系\n每个节点都有一个`childNodes`属性，其中保存着一个`NodeList`对象。\n`NodeList`是类数组对象（不是快照的那种）。`NodeList`可以用方括号或者`item()`取节点。\n\n每个节点有一个`parentNode`属性，指向父节点。\n还有兄弟节点`previousSibling`和`nextSibling`。\n所有节点都有一个ownerDocument，指向整个文档的文档节点。\n(...没意思不想写惹_(:з」∠)_)\n\n### 操作节点\n\nFunction | Description\n---|---\nappendChild | 插入末尾\ninsertBefore(要插入的, 参照的节点) | 插入最前\nreplaceChild(要插入的，要替换的)| 替换\nremoveChild | 移除\ncloneNode | 复制（因为ie下的bug，所以福之前最好移除事件）\nnormalize | 移除不包含文本的文本节点，合并文本节点\n\n## Node类型\n因为IE没有公开Node的构造函数，所以最好还是用数字作比较\n\nConstant | Value | Description\n---|---|---\nNode.ELEMENT_NODE | 1 | nodeName为标签名，nodeValue是null\nNode. ATTRIBUTE_ NODE | 2 | nodeName是属性名，nodeValue是属性值名，不支持子节点\nNode.TEXT_NODE | 3 | nodeName是\"#text\"，nodeValue是包含的文本，不支持子节点\nNode.CDATA_SECTION_NODE | 4 | nodeName是\"#cdata-section\"，nodeValue是CDATA区域内容，不支持子节点\nNode.ENTITY_REFERENCE_NODE | 5\nNode.ENTITY_NODE | 6\nNode.PROCESSING_INSTRUCTION_NODE | 7\nNode.COMMENT_NODE | 8 | nodeName是\"#comment\"， nodeValue是注释内容，不支持子节点\nNode.DOCUMENT_NODE | 9 | 是HTMLDocument的一个实例，nodeName是\"#document\"，nodeValue是null，parentNode是null，ownerDocument是null\nNode.DOCUMENT_TYPE_NODE | 10 | nodeName是doctype的名称，nodeValue是null，不支持子节点\nNode.DOCUMENT_FRAGMENT_NODE | 11 | nodeName是\"#document-fragment\"，nodeValue是null，parentNode是null\nNode.NOTATION_NODE | 12\n\n\n## Document\n\n### 文档子节点\nDocument节点的子节点可以是DocumentType、Element、ProcessingInstruction或Comment。\n几个快捷属性：\n1. `document.documentElement`属性始终指向<html>元素。\n2. `document.body`属性始终指向<body>元素。\n3. `document.doctype`指向<!doctype>元素。（ie8及以前返回null）\n如果子节点包含Comment，在Chrome中测试，仅会为第一条Comment创建节点。据说ie9及更高会为所有Comment创建节点，FF和Safari3.1之前会忽略。\n\n### 文档信息\n1. document.title\n2. document.URL\n3. document.domain\n4. document.referrer\n\n### 特殊集合\n1. document.anchors\n2. document.applets\n3. document.forms\n4. document.images\n5. document.links\n\n### 一致性检查\n1. document.implementation.hasFeature(功能, 版本号) //返回true不代表实现与规范一致\n\n## Element\n\n### 标准特性\n1. id\n2. title\n3. lang\n4. dir\n5. className\n6. attributes\n...\n\n一般来说所有特性都是属性，不过如果为DOM元素自定义一个属性，不会自动成为元素的特性\n```\ndiv.myColor = \"red\";\nconsole.log(div.getAttribute(\"myColor\")) //null (除ie)\n```\n\n### attributes\n该属性是Element类型唯一一个DOM类型节点。\n方法：\n1. getNamedItem(name)\n2. removeNamedItem(name) //删除后返回被删除节点\n3. setNamedItem(name)\n4. item(position)\n\nattributes对象中的特性不同浏览器返回顺序不同\nie7及更早会返回HTML元素中所有可能的特性，但指定特性specified属性为true\n\n## Attr\n虽然也是节点，但是不被认为是DOM文档树的一部分\n\n### 属性\n1. name 特性名\n2. value 特性值\n3. specified 是否是指定的\n\n## Text\n\n### 方法\n1. appendData(text) 添加文本到结尾\n2. deleteData(offset, count) 从offset开始删除count个字符\n3. insertData(offset, text) 从offset开始插入text\n4. replaceData(offset, count, text) 从offset开始把count个字符替换成text\n5. splitText(offset) 从offset分割文本\n6. substringData(offset, count) 从offset提取count个字符\n7. createTextNode 创建文本节点\n\n可以通过data属性获取文本内容\n\n## Comment\n与Text继承自相同基类\n因此他拥有除splitText外所有的操作方法\n\n## DocumentType\n不常用，并不是所有浏览器都支持他\n不能动态创建\n\n### 属性\n1. name //代表文档类型名称\n2. entities //由文档类型描述的实体的NamedNodeMap对象，chrome试了没这个属性\n3. notations //是由文档类型描述的符号的NamedNodeMap对象，chrome试了没这个属性\n\n## DocumentFragment\n是一种轻量级的文档，可以通过createDocumentFragment()创建文档片段\n\n","tags":["html"]},{"title":"New Relic 中文文档","url":"/2017/05/18/new-relic-doc-zh-CN/","content":"# New Relic Node.js代理文档\n\n## 系统要求\n\n* 操作系统：\n\t*  Linux\n\t*  SmartOS\n\t*  MacOSX 10.7 及更高\n\t*  Windows Server 2008 及更高\n* NODE版本： 使用最高稳定版本(现在是6.x版本)的NODE会为New Relic带来更好的体验。支持4.x及最新版本，但不支持不稳定版本的NODE（不支持0.10.34版本）。\n* 框架：\n\t* Express2.0及更高。\n\t* Restify\n\t* Connect 1 and Connect 2 (不支持router)\n\t* Hapi\n\t* Kraken\n\t* 如果你使用的是框架的默认路由，那么New Relic的NODE代理是可以读到这些路由名的。但是如果你希望使用自定义的名字，那么你可以用[node.js 事务命名 API](https://docs.newrelic.com/docs/agents/nodejs-agent/supported-features/nodejs-agent-api)\n* 数据存储：\n\t* Cassandra（配合cassandra-driver，而且NODE版本要0.10或更高)\n\t* Memcached\n\t* MongoDB\n\t* MySQL 0.9 and 2.0\n\t* Redis\n\t* Postgres\n\t* Oracle\n* 主机服务\n\t* Heroku\n\t* Microsoft Azure\n\t* AWS EC2\n* 安全要求\n\t* 支持SHA-2(256-bit)，不支持SHA-1\n\n## 安装\n### 指南\n* 在NODE最新的稳定版本上有最好的体验，最低支持0.8版本，不支持不稳定版本\n* `npm install newrelic --save`\n* 从`node_modules/newrelic`中把`newrelic.js`拷贝到应用的根目录下\n* 修改`newrelic.js`，特别重要的是要把`license_key`更换成自己账号的(可以在Account Setting)中找到\n* 在你的应用的主模块第一行中`require('newrelic');`\n* 选用: 为了保证你应用配置独立于应用，可以在配置`NEW_RELIC_HOME`变量(如果使用的是`bash`，那么在~/.bashrc中配置`export NEW_RELIC_HOME=\"引用根目录\"`)\n* 选用: 在New Relic的界面配置服务端需要的参数\n* 选用: 安装`@newrelic/native-metrics`包，作为额外的NODE运行状况监测工具\n\n### 可以看你的应用运行状况啦\n在 `APM > Applications > (selected app) > Overview`中查看\n\n### 记得及时更新\n\n## NODE代理配置\n\n你可以通过修改`newrelic.js`的配置来设置你的环境变量，你也可以通过管理界面来修改一些，还有记得要把`newrelic.js`放在应用根目录下面哟\n\n### 配置方法和优先级\n主要的推荐的配置方法就是修改那个js。\n优先级如图\n![优先级](https://docs.newrelic.com/sites/default/files/styles/full_size/public/thumbnails/image/nodejs%20config%20cascade_0.png?itok=r_yPD--g)\n### 可配置变量\n一般就是说在那个js里面配的，可以配在环境变量里面的会另外说明名字什么的。用`exports.config = {`裹住。\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n\t<thead>\n\t<tr>\n\t\t<th>名字</th>\n\t\t<th>类型</th>\n\t\t<th>默认值</th>\n\t\t<th>环境变量名</th>\n\t\t<th>其他</th>\n\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>**`app_name`**</td>\n\t\t\t<td>String</td>\n\t\t\t<td>\"My Application\"</td>\n\t\t\t<td>`NEW_RELIC_APP_NAME`</td>\n\t\t\t<td>必要的，可以写多个。Azure用户还有些其他的嘱咐，自己去[看](https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/nodejs-agent-configuration)吧</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>**`license_key`**</td>\n\t\t\t<td>String</td>\n\t\t\t<td></td>\n\t\t\t<td>`NEW_RELIC_LICENSE_KEY`</td>\n\t\t\t<td>在Account Setting里面靠右边可以找到</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`host`</td>\n\t\t\t<td>String</td>\n\t\t\t<td>collector.newrelic.com</td>\n\t\t\t<td>`NEW_RELIC_HOST`</td>\n\t\t\t<td>不要编辑这个变量，除非New Relic Support要求你修改它(这个是[New Relic collector](https://docs.newrelic.com/docs/accounts-partnerships/education/getting-started-new-relic/glossary#collector)用的)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`port`</td>\n\t\t\t<td>Integer</td>\n\t\t\t<td>443</td>\n\t\t\t<td>`NEW_RELIC_PORT`</td>\n\t\t\t<td>不要编辑这个变量，除非New Relic Support要求你修改它(这个是[New Relic collector](https://docs.newrelic.com/docs/accounts-partnerships/education/getting-started-new-relic/glossary#collector)用的)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`proxy`</td>\n\t\t\t<td>String</td>\n\t\t\t<td></td>\n\t\t\t<td>`NEW_RELIC_PROXY_URL`</td>\n\t\t\t<td>如果你用了`proxy`配置，它会覆盖其他的代理配置(`proxy_host`, `proxy_port`, `proxy_user`, `proxy_pass`)。同理，`NEW_RELIC_PROXY_URL`环境变量也会覆盖掉其他代理的环境变量配置</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`proxy_host`</td>\n\t\t\t<td>String</td>\n\t\t\t<td></td>\n\t\t\t<td>`NEW_RELIC_PROXY_HOST`</td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`proxy_port`</td>\n\t\t\t<td>String</td>\n\t\t\t<td></td>\n\t\t\t<td>`NEW_RELIC_PROXY_PORT`</td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`proxy_user`</td>\n\t\t\t<td>String</td>\n\t\t\t<td></td>\n\t\t\t<td>`NEW_RELIC_PROXY_USER`</td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`proxy_pass`</td>\n\t\t\t<td>String</td>\n\t\t\t<td></td>\n\t\t\t<td>`NEW_RELIC_PROXY_PASS`</td>\n\t\t\t<td>密码</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`ignore_server_configuration`</td>\n\t\t\t<td>Boolean</td>\n\t\t\t<td>`false`</td>\n\t\t\t<td>`NEW_RELIC_IGNORE_SERVER_CONFIGURATION`</td>\n\t\t\t<td>启用后会忽略服务端配置</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`agent_enabled`</td>\n\t\t\t<td>Boolean</td>\n\t\t\t<td>`true`</td>\n\t\t\t<td>`NEW_RELIC_ENABLED`</td>\n\t\t\t<td>设置成`false`停用代理，可以在开发时临时使用</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`apdex_t`</td>\n\t\t\t<td>Number</td>\n\t\t\t<td>`0.100`</td>\n\t\t\t<td>`NEW_RELIC_APDEX`</td>\n\t\t\t<td>性能指数，服务端配置名是`Apdex T`。单位是秒。你可以在服务端配置它。100毫秒是低于标准New Relic性能配置的。但是node.js比别的语言要延时敏感一些。具体可以看[这边](https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/nodejs-agent-configuration#tracer_threshold)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`capture_params`</td>\n\t\t\t<td>Boolean</td>\n\t\t\t<td>`false`</td>\n\t\t\t<td>`NEW_RELIC_CAPTURE_PARAMS`</td>\n\t\t\t<td>启用后可以捕获请求参数(配合`事务追踪配置`和 `错误追踪配置`)，因为他会放过一些敏感数据，所以默认是`false`。补充设置可以查看`ssl`和`ignored_params`</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`ignored_params`</td>\n\t\t\t<td>String</td>\n\t\t\t<td></td>\n\t\t\t<td>`NEW_RELIC_IGNORED_PARAMS`</td>\n\t\t\t<td>列一堆不需要补货的参数名，默认是`ignored_params : []`</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`ssl`</td>\n\t\t\t<td>Boolean</td>\n\t\t\t<td>`true`</td>\n\t\t\t<td>`NEW_RELIC_USE_SSL`</td>\n\t\t\t<td>如果你设置了`high_security`一定要启用。一般情况下，你会在`安全v1模式`下的，如果你关了`ssl`还启用了`capture_params`，那你就退出了高安全模式，会组织代理链接高安全账户，这时你的log会出现`ERROR Account Security Violation`错误</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`certificates`</td>\n\t\t\t<td>Array of strings</td>\n\t\t\t<td></td>\n\t\t\t<td></td>\n\t\t\t<td>`certificates: [ fs.readFileSync('myca.crt', {encoding: 'utf8'}) ]`</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`high_security`</td>\n\t\t\t<td>Boolean</td>\n\t\t\t<td>`false`</td>\n\t\t\t<td>`NEW_RELIC_HIGH_SECURITY`</td>\n\t\t\t<td>启用后进入`安全v2模式`，同时必须启用`ssl`，还有在管理界面中启用`high security`</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`browser_monitoring.enable`</td>\n\t\t\t<td>Boolean</td>\n\t\t\t<td>`true`</td>\n\t\t\t<td>`NEW_RELIC_BROWSER_MONITOR_ENABLE`</td>\n\t\t\t<td>服务端标签是`Enable browser monitoring?`。为页面加载计时生成JavaScript标头，但是除非你启用了`New Relic Browser`，这个并没有什么卵用</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>`label`</td>\n\t\t\t<td>Object or string</td>\n\t\t\t<td></td>\n\t\t\t<td>`NEW_RELIC_LABELS`</td>\n\t\t\t<td>例子： `Server:One;Data Center:Primary`</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n### 日志变量\n在`newrelic.js`里面用`logging`变量申明的\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>名字</th>\n\t\t\t<th>类型</th>\n\t\t\t<th>默认</th>\n\t\t\t<th>环境变量</th>\n\t\t\t<th>其他</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr>\n\t\t<td>`level`</td>\n\t\t<td>String</td>\n\t\t<td>`info`</td>\n\t\t<td>`NEW_RELIC_LOG_LEVEL`</td>\n\t\t<td>用了[bunyan](https://github.com/trentm/node-bunyan)模块，共有`fatal`, `error`, `warn`, `info`, `debug`, `trace`这几种类型。一般情况下用`info`即可，非必要最好不要用`trance`或`debug`，因为会产生过多的记录</td>\n\t</tr>\n\t<tr>\n\t\t<td>`filepath`</td>\n\t\t<td>String</td>\n\t\t<td>`require('path').join(process.cwd(), 'newrelic_agent.log')`</td>\n\t\t<td>`NEW_RELIC_LOG`</td>\n\t\t<td>如果创建不了这个文件的话进程会挂掉</td>\n\t</tr>\n\t</tbody>\n</table>\n\n### 审核日志\n在`newrelic.js`里面用`audit_log`变量申明的\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>名字</th>\n\t\t\t<th>类型</th>\n\t\t\t<th>默认</th>\n\t\t\t<th>环境变量</th>\n\t\t\t<th>其他</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr>\n\t\t<td>`enabled`</td>\n\t\t<td>Boolean</td>\n\t\t<td>`false`</td>\n\t\t<td>`NEW_RELIC_AUDIT_LOG_ENABLED`</td>\n\t\t<td>启用时，代理会记录发送给收集器的有效内容。即使日志等级较低也会包含在主日志文件里边</td>\n\t</tr>\n\t<tr>\n\t\t<td>`endpoints`</td>\n\t\t<td>Array</td>\n\t\t<td>空数组 (包含所有类型)</td>\n\t\t<td>`NEW_RELIC_AUDIT_LOG_ENDPOINTS`</td>\n\t\t<td>\n\t\t代理在单独的有效负载中向收集器发送几种不同类型的数据。 默认情况下，它们都包含在日志文件中。 此选项可以将日志记录限制到特定类型的数据。可用的类型有：\n\n1. `metric_data`\n1. `error_data`\n1. `analytic_event_data`\n1. `custom_event_data`\n1. `error_event_data`\n1. `transaction_sample_data`\n1. `sql_trace_data`\n1. `connect`\n1. `agent_settings`\n1. `get_redirect_host`\n1. `shutdown`\n\t\t</td>\n\t</tr>\n\t</tbody>\n</table>\n\n### 错误收集变量\n在`newrelic.js`里面用`error_collector`变量申明的\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>名字</th>\n\t\t\t<th>类型</th>\n\t\t\t<th>默认</th>\n\t\t\t<th>环境变量</th>\n\t\t\t<th>其他</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr>\n\t\t<td>`enabled`</td>\n\t\t<td>Boolean</td>\n\t\t<td>`true`</td>\n\t\t<td>`NEW_RELIC_ERROR_COLLECTOR_ENABLED`</td>\n\t\t<td>服务端标签是`Enable error collection?`。启用后代理会收集错误信息</td>\n\t</tr>\n\t<tr>\n\t\t<td>`ignore_status_codes`</td>\n\t\t<td>Array</td>\n\t\t<td>`404`</td>\n\t\t<td>`NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES`</td>\n\t\t<td>服务端标签是`Ignore these status codes`。以逗号分隔需要被忽略的HTTP状态码</td>\n\t</tr>\n\t</tbody>\n</table>\n\n### 事务追踪变量\n代理将你的请求分组为事务，用于：\n\n* 可视化引用在事务故障上花费的时间\n* 识别缓慢请求\n* 组指标\n* 隔离其他问题，比如说辣鸡数据库性能\n\n在`newrelic.js`里面用`transaction_tracer`变量申明的\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>名字</th>\n\t\t\t<th>类型</th>\n\t\t\t<th>默认</th>\n\t\t\t<th>环境变量</th>\n\t\t\t<th>其他</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr>\n\t\t<td>`enabled`</td>\n\t\t<td>Boolean</td>\n\t\t<td>`true`</td>\n\t\t<td>`NEW_RELIC_TRACER_ENABLED`</td>\n\t\t<td>服务端标签是`Enable transaction tracing?`。启用后代理会收集慢事务</td>\n\t</tr>\n\t<tr>\n\t\t<td>`transaction_threshold`</td>\n\t\t<td>Integer 或 `apdex_f`</td>\n\t\t<td>`apdex_f`</td>\n\t\t<td>`NEW_RELIC_TRACER_THRESHOLD`</td>\n\t\t<td>服务端标签是`Threshold`。web事务响应时间（以秒为单位）的阈值，超过该值，事务将有资格进行事务跟踪。 默认值为`apdex_f`; 这将跟踪阈值设置为应用程序的`apdex_f`的四倍。您还可以输入特定的时间值（以毫秒为单位）。</td>\n\t</tr>\n\t<tr>\n\t\t<td>`top_n`</td>\n\t\t<td>Integer</td>\n\t\t<td>`20`</td>\n\t\t<td>`NEW_RELIC_TRACER_TOP_N`</td>\n\t\t<td>定义适用于事务跟踪的最大请求数。要记录最后一分钟的绝对最慢事务，您可以设置top_n：0或top_n：1。但是，这会导致一个非常慢的路由来支配事务跟踪。\n\t\t</td>\n\t</tr>\n\t<tr>\n\t\t<td>`record_sql`</td>\n\t\t<td>String (`off`, `obfuscated`, `raw`)</td>\n\t\t<td>`off`</td>\n\t\t<td>`NEW_RELIC_RECORD_SQL`</td>\n\t\t<td>此选项同时影响事务跟踪的慢查询和record_sql。设置为`off`时，不会捕获缓慢的查询，并且事务跟踪中将不包括回溯和SQL。 如果设置为`raw`或`obfuscated`，代理将原始或模糊的SQL和慢速查询样本发送到收集器。 代理也可以在满足其他条件时发送SQL，例如，设置了`slow_sql.enabled`。\t\t</td>\n\t</tr>\n\t<tr>\n\t\t<td>`explain_threshold`</td>\n\t\t<td>Integer</td>\n\t\t<td>`500`</td>\n\t\t<td>`NEW_RELIC_EXPLAIN_THRESHOLD`</td>\n\t\t<td>事务的最小查询长度（以毫秒为单位），适用于慢速查询和事务跟踪。</td>\n\t</tr>\n\t</tbody>\n</table>\n\n### 调试变量\n在`newrelic.js`里面用`debug`变量申明的\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>名字</th>\n\t\t\t<th>类型</th>\n\t\t\t<th>默认</th>\n\t\t\t<th>环境变量</th>\n\t\t\t<th>其他</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr>\n\t\t<td>`internal_metrics`</td>\n\t\t<td>Boolean</td>\n\t\t<td>`false`</td>\n\t\t<td>`NEW_RELIC_DEBUG_METRICS`</td>\n\t\t<td>不要随便修改这个值，除非New Relic要你改。启用后，代理程序将收集内部可支持性指标和诊断以及性能指标。</td>\n\t</tr>\n\t<tr>\n\t\t<td>`tracer_tracing`</td>\n\t\t<td>Boolean</td>\n\t\t<td>`false`</td>\n\t\t<td>`NEW_RELIC_DEBUG_TRACER `</td>\n\t\t<td>不要随便修改这个值，除非New Relic要你改。启用后，代理会跟踪事务跟踪器本身的内部操作。 需要将日志级别设置为`trace`。</td>\n\t</tr>\n\t</tbody>\n</table>\n\n### 规则变量\n在`newrelic.js`里面用`rules`变量申明的\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>名字</th>\n\t\t\t<th>类型</th>\n\t\t\t<th>默认</th>\n\t\t\t<th>环境变量</th>\n\t\t\t<th>其他</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr>\n\t\t<td>`name`</td>\n\t\t<td>Strings 或 regular expressions</td>\n\t\t<td></td>\n\t\t<td>`NEW_RELIC_NAMING_RULES`</td>\n\t\t<td>以逗号分隔的规则列表，以匹配传入请求URL并命名关联的New Relic事务。使用格式{pattern：'STRING_OR_REGEX'，name：'NAME'}。正则支持`JavaScript`风格的捕获组以及$1风格的替换字符串。正则表达式只找到第一个匹配结果; 后续匹配被忽略。更多请查看[node.js 事务命名 API](https://docs.newrelic.com/docs/agents/nodejs-agent/supported-features/nodejs-agent-api)。对于`NEW_RELIC_NAMING_RULES `环境变量，将规则作为逗号分隔的JSON对象常量传递，如:`NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}'` </td>\n\t</tr>\n\t<tr>\n\t\t<td>`ignore`</td>\n\t\t<td>Strings 或 regular expressions</td>\n\t\t<td>正则表达式匹配socket.io长轮询请求`(\"^\\/socket\\.io\\/.*\\/xhr-polling/\")`</td>\n\t\t<td>`NEW_RELIC_IGNORING_RULES`</td>\n\t\t<td>定义希望代理忽略的请求URL列表。</td>\n\t</tr>\n\t<tr>\n\t\t<td>`enforce_backstop`</td>\n\t\t<td> Boolean</td>\n\t\t<td>`true`</td>\n\t\t<td>`NEW_RELIC_IGNORING_RULES`</td>\n\t\t<td>除非你了解[指标分组问题](https://docs.newrelic.com/docs/features/metric-grouping-issues)，否则请勿更改此设置。启用时，代理将不受其他命名逻辑（API，规则(`rules`)或度量标准化规则(`metric normalization rules`)）影响的事务重命名为`NormalizedUri/*`。 如果将此值设置为false，代理将事务名称设置为`Uri/path/to/resource`。</td>\n\t</tr>\n\t</tbody>\n</table>\n\n### 事务事件变量\n在`newrelic.js`里面用`transaction_events`变量申明的。当前没有事务事件的环境变量。\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>名字</th>\n\t\t\t<th>类型</th>\n\t\t\t<th>默认</th>\n\t\t\t<th>其他</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr>\n\t\t<td>`enabled`</td>\n\t\t<td>Boolean</td>\n\t\t<td>`true`</td>\n\t\t<td>启用时，代理将事务事件发送到[New Relic Insights](https://docs.newrelic.com/docs/insights)。此事件数据包括事务时间，事务名称和任何自定义参数。如果禁用此选项，则代理程序不会收集此数据或将其发送到Insights。\n</td>\n\t</tr>\n\t<tr>\n\t\t<td>`max_samples_per_minute`</td>\n\t\t<td>Integer</td>\n\t\t<td>10000</td>\n\t\t<td>定义代理每分钟收集的最大事件数。如果有超过此数字，代理将收集统计抽样。</td>\n\t</tr>\n\t<tr>\n\t\t<td>`max_samples_stored`</td>\n\t\t<td> Integer </td>\n\t\t<td>20000</td>\n\t\t<td>定义代理程序无法与New Relic收集器通信时存储的事件的最大数量。确保此数字大于`max_samples_per_minute`。在增加此值之前，务必考虑内存开销。</td>\n\t</tr>\n\t</tbody>\n</table>\n\n### 慢查询变量\n在`newrelic.js`里面用`slow_sql`变量申明的。\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>名字</th>\n\t\t\t<th>类型</th>\n\t\t\t<th>默认</th>\n\t\t\t<th>环境变量</th>\n\t\t\t<th>其他</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr>\n\t\t<td>`enabled`</td>\n\t\t<td>Boolean</td>\n\t\t<td>`false`</td>\n\t\t<td>`NEW_RELIC_SLOW_SQL_ENABLED`</td>\n\t\t<td>启用时，代理会收集慢查询的详细内容</td>\n\t</tr>\n\t<tr>\n\t\t<td>`max_samples`</td>\n\t\t<td>Integer</td>\n\t\t<td>10</td>\n\t\t<td>`NEW_RELIC_MAX_SQL_SAMPLES`</td>\n\t\t<td>定义代理每分钟收集的慢速查询的最大数量。在达到限制后，代理将丢弃其他查询。使用增加该变量会增大内存消耗。</td>\n\t</tr>\n\t</tbody>\n</table>\n\n### 自定义主机名变量\n在`newrelic.js`里面用`process_host`变量申明的。这些选项控制有关New Relic APM UI中主机显示名称的行为。\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>名字</th>\n\t\t\t<th>类型</th>\n\t\t\t<th>默认</th>\n\t\t\t<th>环境变量</th>\n\t\t\t<th>其他</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr>\n\t\t<td>`display_name`</td>\n\t\t<td>String of 255 bytes or less</td>\n\t\t<td></td>\n\t\t<td>`NEW_RELIC_PROCESS_HOST_DISPLAY_NAME`</td>\n\t\t<td>指定要在New Relic UI中显示的自定义主机名。如果不设置此字段，New Relic将调用`os.hostname()`找到的默认主机名。</td>\n\t</tr>\n\t<tr>\n\t\t<td>`ipv_preference`</td>\n\t\t<td>Integer(`4` 或 `6`)</td>\n\t\t<td>4</td>\n\t\t<td>`NEW_RELIC_IPV_PREFERENCE`</td>\n\t\t<td>如果你的`display_name`用的是默认设置，那么当获取不到默认主机名时，会展示ip。</td>\n\t</tr>\n\t</tbody>\n</table>\n\n### 环境变量重写\n本节定义了两个仅通过环境变量可用的配置选项。 这些重写在大多数配置中不使用。\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>名字</th>\n\t\t\t<th>类型</th>\n\t\t\t<th>默认</th>\n\t\t\t<th>其他</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr>\n\t\t<td>`NEW_RELIC_HOME`</td>\n\t\t<td>String</td>\n\t\t<td></td>\n\t\t<td>只能作为环境变量配置，配置的是包含`newrelic.js`的文件夹路径</td>\n\t</tr>\n\t<tr>\n\t\t<td>`NEW_RELIC_NO_CONFIG_FILE`</td>\n\t\t<td>Boolean</td>\n\t\t<td>`false`</td>\n\t\t<td>只能作为环境变量配置，阻止代理从newrelic.js读取配置设置</td>\n\t</tr>\n\t</tbody>\n</table>\n\n### 数据库追踪变量\n在`newrelic.js`里面用`datastore_tracer`变量申明的。\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>名字</th>\n\t\t\t<th>类型</th>\n\t\t\t<th>默认</th>\n\t\t\t<th>其他</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr>\n\t\t<td>`instance_reporting.enabled`</td>\n\t\t<td>Boolean</td>\n\t\t<td>`true`</td>\n\t\t<td>启用时，代理会收集某些数据库驱动程序的数据存储实例度量标准（例如主机和端口）。这些报告在慢查询跟踪和事务跟踪。</td>\n\t</tr>\n\t<tr>\n\t\t<td>`database_name_reporting.enabled`</td>\n\t\t<td>Boolean</td>\n\t\t<td>`true`</td>\n\t\t<td>启用后，代理将在某些数据库驱动程序的慢查询跟踪和事务跟踪上收集数据库名称。</td>\n\t</tr>\n\t</tbody>\n</table>\n\n## Node.js代理属性\n在New Relic产品中，属性是从你应用中事务和事件中收集的键值对。New Relic的Node.js代理从HTTP请求和响应头中收集了一些基础的属性。\n\n### Node.js代理属性\nNew Relic Node.js代理默认捕获一些基础的HTTP头数据，比如HTTP响应码和请求方式。NNew Relic将此默认数据称为代理属性。New Relic Node.js代理收集的属性的数据显示在：\n\n* 事务事件\n* 事务追踪\n* 错误追踪\n* 错误事件\n\n你也可以添加自定义工具以捕获任何其他属性。\n以下是一些默认属性：\n\n1. `request.headers.accept`\n2. `request.headers.host`\n3. `request.headers.referer`\n4. `request.headers.userAgent`\n5. `request.method`\n6. `httpResponseCode`\n7. `httpResponseMessage`\n8. `response.headers.contentLength`\n9. `response.headers.contentType`\n\n### 创建自定义属性\n创建自定义属性可以用以下任意方式：\n\n* 创建一个自定义事件：使用**`recordCustomEvent`**\n* 添加到现有事务：使用**`addCustomParameters`**\n* 添加多个属性： 使用**`addCustomParameters`**\n\n## 支持的特性\n\n### Node.js代理API\nNew Relic提供了多个工具帮助获取提供有关Node.js应用程序的有用指标所需的信息。包括：\n\n* 从Express和Restify路由器读取路由名称（如果使用）\n* 使用API命名当前请求，或使用简单的名称或操作控制器组\n* 支持存储在代理配置中的规则，可以根据请求的原始URL（也可作为API调用）匹配的正则表达式来标记要重命名或忽略的请求。\n为保证用户体验，New Relic需要跟踪足够小的名称数量。这也需要足够大以提供适当的信息量（不会使您的数据压倒），以便您可以更容易地识别您的应用程序中的问题点。\n\n#### 请求名称\nNode.js代理捕获HTTP方法使用一个潜在参数化的路径，类似于` /user/:id`，或正则，比如`/^/user/([-0-9a-f]+)/`。这些信息会成为请求名的一部分。\n如果你支持慢事务追踪或者在配置文件中开启了`capture_params`，那么事务追踪会捕获请求参数和值。如果你对Node.js代理的请求名不满意，你也可以使用API创建描述性的名称。\n*如果按通用名称对请求进行分组，则`/*`就足够了，您不需要自定义配置文件或API调用。*\n\n#### 请求\nNew Relic使用请求名以将请求分组成多个图表。随着不同请求名称的数量增加，这些可视化的值将下降。\n例如，不要在创建的请求名称中包含高度可变的信息，如GUID，数字ID或时间戳。如果你的请求速度足以生成事务跟踪，则该跟踪将包含原始URL。如果你启用参数捕捉，那么这些参数也会被捕获。\n*避免拥有超过50个不同的事务名称。例如，如果您有超过几百个不同的请求名称，请重新思考您的命名策略。*\n\n#### 避免度量分组问题\n请求命名API帮助New Relic避免尝试处理太多指标的问题，有时称为“指标爆炸”。 New Relic有几个解决策略。最严重的是简单地将违规应用程序列入黑名单。你在使用这些请求命名工具时要小心的主要原因是为了防止这种情况发生在你的应用程序中。\n\n\n#### 指南\n定义您的配置规则从最一般到最具体。\n配置文件中列出或添加的第一个Node.js事务命名API规则应该是最通用的“通用”规则。\n更加详细的规则应该被添加到列表的末尾，因为它们会以相反顺序进行评估。\n\n***例子***\n有个网站的url大概长这样\n\n```javascript\n  /user/customers/all/prospects\n  /user/customers/all/current\n  /user/customers/all/returning\n  /user/customers/John\n  /user/customers/Jane\n```\n那么他配的规则可以是这样\n\n```javascript\n  // newrelic.js\n  exports.config={\n    //other configuration\n    rules:{\n      name:[\n      { pattern: \"/user/customers/.*\", name: \"/user/customers/:customer\" },\n      { pattern: \"/user/customers/all/.*\", name: \"/user/customers/all\" },\n      { pattern: \"/user/customers/all/prospects/\", name: \"/user/customers/all/prospects\" }\n  ]\n}\n```\n根据这些规则，将会创建三个事务名\n\n```javascript\n/user/customers/:customer\n/user/customers/all\n/user/customers/all/prospects\n```\n如果把规则写反了的话，就会全部捕获成`:customer`事务。\n\n#### 加载请求名API\n确保在应用最前面加载New Relic模块\n\n```javascript\nvar newrelic = require('newrelic');\n```\n这返回请求命名API。您可以安全地从应用程序中的多个模块导入模块，因为它只初始化一次。\n\n#### 请求API\n\n* **`newrelic.setTransactionName(name)`**\n根据请求命名规则命名当前请求。你可以在任意HTTP请求句柄上下文中调用该函数(需在请求处理开始后和请求结束前)。一般来说，您可设置名称在请求和相应在作用域内。\n显式调用`newrelic.setTransactionName()`会将`Express`或`Restify`路由设置的名称覆盖。同时，调用`newrelic.setTransactionName()`和`newrelic.setControllerName()`会互相覆盖。\n\n* **`newrelic.setControllerName(name, [action])`**\n使用控制器样式模式命名当前请求，可选择包括当前控制器操作。\n如果省略`action`，`New Relic`会把HTTP方法（GET，POST等）作为`action`。调用`newrelic.setControllerName()`的规则与`newrelic.setTransactionName()`相同，包括请求命名要求。\n显示调用`newrelic.setControllerName()`会将`Express`或`Restify`路由设置的名称覆盖。同时，调用`newrelic.setTransactionName()`和`newrelic.setControllerName()`会互相覆盖。\n\n#### 自定义检测API\n使用这些API来扩展检测工具\n\n* **`createWebTransaction(url, handle)`**\n检测指定web事务。调用此函数后，可检测New Relic不会自动检测的事务。\n`url`是事务名称并且需要是静态的。不要包括用户ID等变量数据。\n`handle`是检测函数。New Relic将捕获将由自动检测捕获的任何指标，以及通过`createTracer()`进行手动监测的指标。\n如果在一个web事务中调用，那么代理会新建一个段。如果在一个后台事务中调用，那么改调用会创建一个新的独立事务，并捕获新事务内的`handle`内的任何新调用。必须通过调用`endTransaction()`手动结束自定义事务。New Relic会从调用`createWebTransaction()`计时事务，并在调用`endTransaction()`时结束事务。\n\n* **`createBackgroundTransaction(name, [group], handle)`**\n工具指定后台事务。使用此API，您可以扩展New Relic的工具以从后台事务捕获数据。\n`name`是事务名称，需要是静态的。不要包括用户ID等变量数据。\n`group`是可选的，它允许您通过用户界面中的事务类型将类似的作业分组在一起。需要是静态的。`handle`定义了一个函数，其中包含您要检测的整个后台作业。New Relic将捕获将由自动检测捕获的任何指标，以及通过`createTracer()`进行手动监测的指标。必须通过调用`endTransaction()`手动结束自定义事务。New Relic会从调用`createWebTransaction()`计时事务，并在调用`endTransaction()`时结束事务。\n\n* **`endTransaction()`**\n事务结束时需要被调用\n\n* **`createTracer(name, callback)`**\n调用特定的回调以提高事务的可见性。使用此函数来改进特定方法的检测，或通过在目标函数及其父异步函数中调用`createTracer()`来跨越异步边界跟踪工作。\n`name`是追踪器的名字。该名字会在事务追踪中和New Relic UI中作为新度量可见。`callback`是你希望追踪的回调。代理会在`createTracer`被调用后开始计时段，并`callback `回调完成执行时结束段。\n\n#### 自定义指标API\n使用这些API自定义指标\n\n* **`recordMetric(name, value)`**\n使用`recordMetric`记录事件基础的度量指标，通常与特定的持续时间相关联。`name`必须是个符合指标命名规则的`string`。`value`通常是个`number`，有时也可以是`object`。\n当`value`是个数值时，它应表示与事件关联的测量幅度（如特定方法调用的持续时间）。\n当`value`是个对象时，必须包含`count`，`total`，`min`，`max`和`sumOfSquares`的键对值，这些参数都是`number`。如果你希望自己整合指标并定期报告他们(如用`setInterval`)，那么就对表格很有用。这些值将与先前为同一指标收集的值进行汇总。 这些键的名称与平台API使用的键名称相匹配。\n\n* **`incrementMetric(name, [amount])`**\n使用`incrementMetric`升级指标作为一个简单计数器。所选指标的计数将默认从1开始递增。\n\n#### 自定义事件API\n调用此API记录其他[Insights](https://docs.newrelic.com/docs/insights)事件\n\n* **`recordCustomEvent(eventType, attributes)`**\n使用`recordCustomEvent`记录事件基础的指标，通常与特定的持续时间相关联。`eventType`是一个由字母数字字符串，且少于255字符。`attributes`是一个对象。其中的键值必须少于255个字符，其中的值必须是`string`，`number`或`boolean`。\n\n#### 其他API\n\n* **`newrelic.addCustomParameter(name, value)`**\n在`New Relic UI`中设置要与事务跟踪一起显示的自定义参数值。必须在事务的上下文中调用。自定义参数将显示在事务跟踪详细信息视图中，并显示事务的错误。\n*如果您在Insights中使用自定义参数或属性，请避免使用Insights的任何保留字来命名它们。*\n\n* **`newrelic.addCustomParameters(params)`**\n在New Relic UI中设置要与事务跟踪一起显示的多个自定义参数值。参数应作为单个对象传递。必须在事务的上下文中调用。自定义参数将显示在事务跟踪详细信息视图中，并显示事务的错误。*如果您在Insights中使用自定义参数或属性，请避免使用Insights的任何保留字来命名它们。*\n\n* **`newrelic.getBrowserTimingHeader()`**\n返回要插入到HTML网页标题中的HTML代码段，以启用网页加载时间。 HTML将指示浏览器获取一个小的JavaScript文件并启动页面计时器。\n\n* **`newrelic.setIgnoreTransaction(ignored)`**\n告诉模块是否忽略给定的请求。这允许您显式过滤耗时的长轮询和不相关的路由或请求。这还允许您收集否则将被忽略的请求的指标。\n将参数设置为`true`会忽略事务。要防止使用此函数忽略事务，必须传递参数`false`。传递`null`或`undefined`不会更改事务是否被忽略。\n\n* **`newrelic.noticeError(error, [customParameters])`**\n如果您的应用程序正在使用域或`try/catch`子句执行自己的错误处理，但您希望有关应用程序中出现的错误数量的集中管理的所有信息，请使用此函数。与其他Node.js调用不同，这可以在路由处理程序之外使用，但如果从事务范围内调用，则会有额外的上下文。\n\n* **`newrelic.shutdown([options], callback)`**\n使用此方法正常关闭代理。\n`options`:\n\t*  `options.collectPendingData`布尔类型。告诉代理在关闭之前是否向New Relic服务器发送任何挂起的数据。\n\t* `options.timeout`数字类型(ms)。强制关闭之前的默认时间。当`collectPendingData`为`true`时，代理程序将在关闭之前等待连接。此超时对于短期进程（如AWS Lambda）非常有用，以防止进程在尝试连接时保持打开时间过长。\n例子：\n\n```javascript\nnewrelic.shutdown({ collectPendingData: true, timeout: 3000}, function(error) {\n    process.exit()\n  })\n```\n\n#### 命名和忽略请求的规则\n如果不想将调用到New Relic模块直接放入应用程序代码中，可以使用基于模式的规则来命名请求。有两组规则：一个用于重命名请求，一个用于标记要由New Relic的工具忽略的请求。 这里是New Relic的Node.js代理中的规则的结构。\n\n* **`rules.name`**\n\n格式为`{pattern：“pattern”，name：“name”}`的规则列表，用于将传入的请求URL与模式匹配，并命名匹配的New Relic事务的名称。这用作正则表达式替换，您可以将模式设置为字符串或JavaScript正则表达式文字，`pattern`和`name`都是必需的。\n当将正则表达式作为字符串传递时，可以转义反斜杠，因为代理在模式作为字符串给出时不会保留它们。定义您的配置规则从最一般到最具体，因为模式将以相反的顺序被评估，并且是终端性质的。有关详细信息，请参阅命名准则。\n也可以通过环境变量`NEW_RELIC_NAMING_RULES`配置：`    NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}'`\n\n***可选的规则属性***\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"0\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>属性名</th>\n\t\t\t<th>默认</th>\n\t\t\t<th>描述</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t<tr>\n\t\t<td>`terminate_chain`</td>\n\t\t<td>`true`</td>\n\t\t<td>当设置为`true`（默认）时，如果此规则是匹配，则不会评估其他规则。将多个规则一起使用时，将此选项设置为false非常有用。例如，一个规则是可以匹配许多不同URL中的通用模式，同时随后有更详细的规则。</td>\n\t</tr>\n\t<tr>\n\t\t<td>`replace_all`</td>\n\t\t<td>`false`</td>\n\t\t<td>当设置为`true`时，将替换模式的所有匹配项。 否则，只有第一个匹配项将被替换。 在正则表达式中使用g标志将有相同的效果。例如`pattern: '[0-9]+',\nreplace_all: true`。和它有相同作用的是`pattern: /[0-9]+/g`</td>\n\t</tr>\n\t<tr>\n\t\t<td>`precedence`</td>\n\t\t<td>500</td>\n\t\t<td>默认情况下，以从最后到第一个相反的顺序评估规则。 如果您发现此行为违反直觉，则可以通过将功能标志`reverse_naming_rules`设置为`false`来反转执行顺序。此外，如果你希望完全控制排序规则，那你可以给每个规则一个`precedence`属性。`precedence`需要是一个整数，且规则按递增顺序评估</td>\n\t</tr>\n\t</tbody>\n</table>\n\n***测试你的命名规则***\n\nNode.js代理附带了一个用于测试命名规则的命令行工具。有关更多信息，请在安装了应用程序的目录中的终端窗口中运行以下命令：\n`node node_modules/.bin/newrelic-naming-rules`\n\n***命名规则例子***\n\n1. 匹配完整URL\n`pattern: \"^/items/[0-9]+\",name: \"/items/:id\"`\n结果：\n\n```\n/items/123  =>  /items/:id\n/orders/123  =>  /orders/123   (not replaced since the rule is a full match)\n```\n\n2. 替换网址中的第一个匹配\n`pattern: \"[0-9]+\",name: \":id\"`\n结果：\n\n```\n/orders/123  =>  /orders/:id\n/items/123  =>  /items/:id\n/orders/123/items/123  =>  /orders/:id/items/123\n```\n\n3. 替换任何网址中的所有匹配项\n`pattern: \"[0-9]+\",name: \":id\",replace_all: true`\n结果：\n`/orders/123/items/123  =>  /orders/:id/items/:id`\n\n4. 匹配组引用\n`pattern: '^/(items|orders)/[0-9]+',name: '/\\\\1/:id'`\n结果：\n\n```\n/orders/123  =>  /orders/:id\n/items/123  =>  /items/:id\n```\n\n* **`rules.ignore`**\n这也可以通过环境变量`NEW_RELIC_IGNORING_RULES`设置，多个规则作为逗号分隔模式列表传递。目前没有办法在模式中转义逗号。\n`NEW_RELIC_IGNORING_RULES='^/socket\\.io/\\*/xhr-polling,ignore_me'`\n\n* **例子**\n\t* 命名规则示例\n\n\t\t```\n\t// newrelic.js\n\t  exports.config = {\n\t    // other configuration\n\t    rules : {\n\t      name : [\n\t        { pattern: \"/tables/name-here\", name: \"/name-hererule1\" }\n\t      ]\n\t    }\n\t\t```\n\n\t* 忽略规则示例\n\n\t\t```\n\t\t  // newrelic.js\n\t\t  exports.config = {\n\t\t    // other configuration\n\t\t    rules : {\n\t\t      ignore : [\n\t\t        '^\\/socket\\.io\\/.*\\/xhr-polling'\n\t\t      ]\n\t\t    }\n\t\t  };\n\t\t```\n\n#### API调用规则\n使用New Relic的Node.js代理命名和忽略规则的API。\n\n* **`newrelic.addNamingRule(pattern, name)`**\n程序化版本的`rules.name`。一旦添加了命名规则，在重新启动Node进程之前不能删除它们。它们也可以通过Node.js代理的配置添加。这两个参数都是必需的。\n\n* **`newrelic.addIgnoringRule(pattern)`**\n程序化版本的`rules.ignore`。一旦添加了命名规则，在重新启动Node进程之前不能删除它们。它们也可以通过Node.js代理的配置添加。这两个参数都是必需的。\n\n### Node.js 自定义检测工具\n自定义工具仅在 New Relic 1.10.0及更高版本被支持\n通过自定义工具可以检测websocket，后台工作，不支持的数据库，还可以指向代码的某部分哟\n\n#### 检测web事务\n检测类似于websocket请求的web事务，需要创建一个自定义事务。创建一个自定义事务为您提供与该代理自动处理的事务相同类型的可见性。检测web事务，需要把你需要的检测句柄包裹在**`createWebTransaction()`**中。确保事务结尾调用**`endTransaction()`**。\n\n***例子***\n\n该例子在`socket.io`中检测了一个`/websocket/ping`事务和一个`/websocket/new-message`。`/ping`例子是同步的，`/new-message`例子是异步的。事务结尾调用**`endTransaction()`**。\n\n```javascript\nvar nr = require('newrelic')\nvar app = require('http').createServer()\nvar io = require('socket.io')(app)\n\nio.on('connection', function (socket) {\n  socket.on('ping', nr.createWebTransaction('/websocket/ping', function (data) {\n    socket.emit('pong')\n    nr.endTransaction()\n  }))\n  socket.on('new-message', nr.createWebTransaction('/websocket/new-message', function (data) {\n    addMessageToChat(data, function () {\n      socket.emit('message-received')\n      nr.endTransaction()\n    })\n  }))\n})\n```\n#### 检测后台事务\n你也可以自定义事务检测后台事务，比如说是应用中周期性的工作或是请求后继续完成的工作。检测后台事务需要将句柄包裹在**`createBackgroundTransaction()`**中。确保**`endTransaction()`**在事务的最后。\n\n***例子***\n\n用`setInterval`检测`update:cache`\n\n```javascript\nvar nr = require('newrelic')\nvar redis = require('redis').createClient()\n\nsetInterval(nr.createBackgroundTransaction('update:cache', function () {\n  var newValue = someDataGenerator()\n\n  redis.set('some:cache:key', newValue, function () {\n    nr.endTransaction() // End the transaction once redis is done\n  })\n}), 30000) // Every 30s\n```\n#### 扩展事务检测工具\n你可以使用自定义工具扩展已有的工具提高web事务的可视化，或了解未自动检测的数据库和其他事务内部工作。你需要将你的回调函数包裹在自定义事务追踪器中。\n要调用回调，请使用**`createTracer()`**包装回调。如果要测试在异步函数内调用的函数，则需要使用**`createTracer()`**将目标函数及其父异步函数包装。\n\n***例子***\n\n检测回调\n\n```javascript\n// Wrap the callback in a segment\ndb.createObject(nr.createTracer('db:createObject', function (err, result) {\n  // Some error handler that will end the response for us\n  if (util.handleError(err, res)) {\n    return\n  }\n  res.write(JSON.stringify(result.rows[0].id))\n  res.write('\\n')\n  res.end()\n}))\n```\n\n检测异步函数\n这个例子同时包裹了`pg.connect`和`client.query`。这是因为`client.query`被一个异步父函数(`pg.connect`)调用。否则，我们将不能从`client.query`中获得任何数据。\n这允许**`createTracer()`**在这些异步边界之间传播活动事务。\n\n```javascript\npg.connect(config.db_string, nr.createTracer('pg:connect', function (err, client, done) {\n  if (util.handleError(err, '500', res)) {\n    return done()\n  }\n  client.query('SELECT count(*) FROM test_count', nr.createTracer('pg:query', function (err, result) {\n    if (util.handleError(err, '500', res)) {\n      return done()\n    }\n\n    res.write(result.rows[0].count)\n    res.write('\\n')\n  }))\n}))\n```\n\n### Node.js自定义指标\n自定义指标，可通过API调用记录的任意指标，并创建自定义图表。\n收集太多的指标可能会影响您的应用程序和New Relic的代理的性能。为了避免数据的问题，保持2000下独特的自定义指标总数。\n\n#### 命名指标\n公制名称由路径分隔`/`符。对于自定义指标使用这种模式：\n`<category>/<class>/<method>`\n对于自定义指标名称，使用`Custom/<class>/<method>`或`Custom/<category>/<name>`。例如，使用`Custom/MyCategory/My_method`）。\n\n#### 记录的自定义指标\n记录度量数据的公共API包含在两个方法：\n\n* **`recordMetric`**：用于创建新的自定义指标。\n* **`incrementMetric`**：使用更新的自定义指标的数值。\n\n#### 自定义指标例子\n```javascript\napp.post('/cart/checkout', function(req, res) {\n  var total = computeCartTotal(req.user);\n  newrelic.recordMetric('Custom/Cart/ChargeAmount', total);\n  ...\n});\n```\n\n#### 查看自定义指标\n使用`Insights Metric Explorer`查询，可创建自定义图标等。\n\n\n### 页面加载时间\n使用New Relic的Node.js代理的页面加载时间（有时称为实时用户监测或者RUM），需要是用最新版本的Node.js代理。\n在用户接口启用页面加载时间，请使用[浏览器设置]()。然后按照本节设置页面加载时间用了New Relic的Node.js的代理程序。\n\n#### 插入JavaScript头\nNode.js代理工具可以在应用程序之外继续监测到最终用户的浏览器。`newrelic`模块可以生成脚本头当插入你的HTML模板时，可以捕获用户的页面加载时间。必须手动注入，但不需要额外的配置。\n\n1. 在你html页面`head`标签中，在任意`CHARSET`的`meta`标签后插入**`newrelic.getBrowserTimingHeader()`**的计算结果。（补充：为了最大的IE兼容性，把**`newrelic.getBrowserTimingHeader()`**的计算结果插在`X-UA-COMPATIBLE HTTP-EQUIV`的`meta`标签后面）\n2. 每个请求都调用一下这个头。不要缓存。\n\n#### 例子\n**Express & Jade**\n\n在`app.js`里面\n\n```javascript\n    var newrelic = require('newrelic');\n    var app = require('express')();\n    // in express, this lets you call newrelic from within a template\n    app.locals.newrelic = newrelic;\n\n    app.get('/user/:id', function (req, res) {\n      res.render('user');\n    });\n    app.listen(process.env.PORT);\n\n```\n\n在`layout.jade`里面\n\n```html\n    doctype html\n    html\n      head\n        != newrelic.getBrowserTimingHeader()\n        title= title\n        link(rel='stylesheet', href='stylesheets/style.css')\n      body\n        block content\n```\n\n\n**Express & Swig**\n\n在`app.js`里面\n\n```javascript\n    var newrelic = require('newrelic');\n\n    var http = require('http')\n    var path = require('path')\n    var swig = require('swig')\n\n    var app = require('express')();\n\n    app.locals.newrelic = newrelic;\n\n    //taken from http://paularmstrong.github.io/swig/docs/#express\n    app.engine('html', swig.renderFile);\n    app.set('view engine', 'html');\n    app.set('views', __dirname + '/views');\n\n    app.get('/user/:id', function (req, res) {\n      res.render('user');\n    });\n\n    app.listen(process.env.PORT);\n\n```\n\n在`views/user.html`里面\n\n```html\n    <!DOCTYPE html>\n    <html>\n      <head>\n          {{ newrelic.getBrowserTimingHeader() }}\n          <title>Hello</title>\n      </head>\n        <body>\n          <h1>Hello World</h1>\n        </body>\n    </html>\n```\n\n**Hapi.js & handlebars**\n\n在`app.js`里面\n\n```javascript\n    var newrelic = require('newrelic');\n    var Hapi = require('hapi');\n    var server = new Hapi.Server(parseInt(PORT), '0.0.0.0', {\n      views: {\n        engines : {html: 'handlebars' },\n        path : __dirname + '/templates'\n      }\n    });\n\n    function homepage(request, reply) {\n      var context = {\n\n        // pass in the header each request\n        nreum : newrelic.getBrowserTimingHeader(),\n        content : ...\n    };\n\n    reply.view('homepage', context);\n    };\n\n    server.route({\n      method : 'GET',\n      path : '/',\n      handler : homepage\n    });\n\n    server.start();\n\n```\n\n在`templates/homepage.html`里面\n\n```html\n    <!DOCTYPE html>\n    <html>\n      <head>\n          {{{ nreum }}}\n          <title>Hello</title>\n      </head>\n        <body>\n          {{ content }}\n        </body>\n    </html>\n```\n\n\n#### 禁止头生成\n默认会调用**`newrelic.getBrowserTimingHeader()`**会生成有效的头，当要禁用的时候，需要在模板中移除代码，然后在`newrelic.js`中：\n```javascript\n    browser_monitoring : {\n      enable : false\n    }\n```\n或者把环境变量改改：\n`NEW_RELIC_BROWSER_MONITOR_ENABLE=false`\n\n### NodeVM测量\n[自己看吧](https://docs.newrelic.com/docs/agents/nodejs-agent/supported-features/node-vm-measurements)\n\n### Node.js代理 v2.0 beta\n[自己看吧+1](https://docs.newrelic.com/docs/agents/nodejs-agent/nodejs-agent-v20-instrumentation-api-beta)\n\n## 故障排错\n\n### 安装问题\n#### 问题\n如果在安装New Relic Node.js代理后遇到任何常见问题，请尝试以下故障排除提示。\n#### 解决方案\n* **没有看到数据**\n为了最大限度地减少Node.js代理使用的带宽量，New Relic仅每分钟报告一次数据\n\t* 如果测试环境下代理添加到运行不到一分钟的，它将没有时间将数据报告给New Relic。\n\t* 如果在部署代理后没有看到事务跟踪或其他数据，这可能是由于配置，框架或Apdex设置。\n* **安装问题**\n检查顺序\n\t* 主模块： 确认是否在应用开头`require('newrelic');`。\n\t* 条件逻辑： 如果你在你的`require`时添加了条件逻辑，把你的条件逻辑改到`newrelic.js`里面去\n\t* 框架： 确认你的框架是New Relic支持的\n\t* Apdex： 试试调整你在配置文件的配置和面板的配置\n* **日志文件**\nNode.js代理会将日志写在应用根目录的`newrelic_agent.log`中，除非你修改了日志配置。如果代理不发送数据或崩溃退出应用。你可以生成一个有错误报告和支持请求的故障排除日志文件，可以帮助确定New Relic什么地方出了错。\n* **缺少VM指标**\n代理可以收集与垃圾收集（GC），内存和CPU相关的VM指标。其中一些度量标准需要安装额外的本机模块。\n\t* 问题： 有如下报错时\n\n\t\t```\n\t\tgyp ERR! configure error\ngyp ERR! stack Error: Can't find Python executable \"python\", you can set the PYTHON env variable.\n\t\t```\n\t\t```\n\t\tgyp ERR! build error\ngyp ERR! stack Error: not found: make\n\t\t```\n\t\t```\n\t\tmake: g++: Command not found\n\t\t```\n\n\t* 解决方案： 确保已安装`node-gyp`模块。在Debian / Ubuntu平台上，请使用该命令：`apt-get install build-essential`\n\n### 内存增大问题\n#### 问题\n安装New Relic Node.js代理后使内存使用量增加。\n#### 解决方案\n* **将代理版本升级到1.18.0及更高**\nNode.js代理版本1.18.0缓解了在TLS连接期间可能发生的Node.js内存泄漏。Node.js Core有一个涉及TLS连接时有突出的内存泄漏问题。指定证书的客户端会快速显露此泄露，包括New Relic代理。代理版本1.18.0及更高版本通过尽可能使用默认客户端证书来缓解此问题。当无法使用TLS内存泄漏解决方法时（如使用带有HTTPS代理的自定义证书时），将打印新的日志消息。\n* **因SSL造成的增加**\n为减少因TLS造成的内存溢出，停用SSL。如果停用SSL，需要手动将`port`设`80`。\n* **因TLS内存缓冲区分配引起的增加**\nNode.js应用首次使用任何形式的加密（包括SSL和HTTPS）时，将创建slab缓冲区，默认大小为10 MB。\n\t* 解决方案： 把缓冲区大小设为小于10 MB，可使用[`tls.SLAB_BUFFER_SIZE`](http://nodejs.org/api/tls.html#tls_tls_slab_buffer_size)。当应用运行环境在SSL终止入站请求发生在单独路由层时，通常不会产生此开销。在入站请求的SSL终止发生在单独的路由器层中的环境中运行的应用程序。像Heroku和AWS这样的云服务通常以这种方式运行。 但是，Node.js代理通过HTTPS将出站数据发送到New Relic服务时，将触发slab缓冲区的分配。*使用New Relic代理时，不要将slab缓冲区大小设置为低于128 KB。 对于使用SSL，HTTPS或任何其他形式的加密技术与服务或客户端进行通信的应用程序，不应减少slab缓冲区分配。在使用SSL，HTTPS或任何其他形式的加密技术与服务或客户端进行通信的应用程序时，不应减少slab缓冲区分配。*\n* **因集群工作线程分配引起的增加**\nNode.js提供了集群模块。这允许通过使用服务器上可用的所有处理器核心并行处理请求。但是，每个集群工作者为SSL事务分配自己的slab缓冲区，并保留其自己的Node.js代理数据副本。这会将内存开销乘以使用的集群工作程序数。如果服务器同时运行多个Node.js应用程序，也是如此。\n\t* 解决方案：减少集群工作者数量或不使用集群支持，可能会降低内存使用率但不会影响性能。\n* **因日志信息存储在硬盘引起的增加**\n因为代理默认将日志写在硬盘\n\t* 解决方案：根据Node.js版本，日志级别默认为`info`或`trace`。将日志级别降低到`info`或`warn`级别，以显着降低内存使用和花在垃圾收集中的时间。\n* **因MongoDB游标溢出引起的增加**\n\t* 解决方案： 通过在应用程序完成处理查询结果后调用`cursor.close()`，确保在应用程序中创建的每个游标都已关闭。\n* **因代理数据存储导致的增加**\n\t* 解决方案：如果代理数据存储被识别为内存使用增加的原因，则可以通过向服务器添加更多内存或切换到更大的云服务器实例来解决此问题。\n\n### 页面加载时间问题\n#### 问题\n如果在为页面加载计时（有时称为实时用户监视或RUM）检测New Relic Node.js代理时遇到问题，请按照标准故障排除步骤操作。 这里有一些Node.js的额外提示。\n#### 解决方案\n错误代码会自动出现在网站源代码和你的Node.js代理日志里。可以查询[NREUM](https://docs.newrelic.com/docs/new-relic-browser/troubleshooting-page-view-monitoring#javascript)找到这些代码。\n\n* 错误代码0 :已显示禁用浏览器监控。可在配置`newrelic.js`和环境变量中修改。（`NEW_RELIC_BROWSER_MONITOR_ENABLE`默认是`true`）\n* 错误代码1 :页面加载时间在Web事务之外调用。这可能发生在尝试生成页面加载计时数据一次，然后缓存它，或者如果您在后台任务中调用它。\n* 错误代码2 :发生意外事件。\n* 错误代码3 :事务未命名。 如果您不使用`Express`或`Restify`，并且没有显式地命名事务，则会出现此错误。 这是为了避免将事务名称滚动到`/*`。 有关更多信息，请参阅事务命名。\n* 错误代码4 :Node.js代理还没有与收集器进行“握手”。 应用程序已启动，用户在收集器可以与代理通信之前访问该站点。 这可能是因为：\n\t* 浏览器页面在代理初始化于New Relic的链接前加载\n\t* `license_key`不可用（如果错误持续超过1分钟，很可能是这个问题）\n\t* 发生了一些阻止应用ID可用的问题\n* 错误代码5 :在收集器端禁用了浏览器监视。 例如，收集器未返回足够的数据以启用页面加载计时。 这是一个收集器问题，因为当前的Node.js的服务器端配置不可用。\n\n### 模拟旧参数问题\n#### 问题\n您想要模仿在New Relic UI中启用`Capture`属性或`Capture`参数选项的传统行为。\n#### 解决方案\n可在配置中修改，例如在配置文件中修改为：\n`capture_params : true`\n","tags":["javascript","doc"]},{"title":"如何从闭包中获得变量","url":"/2017/05/18/how-to-get-variable-from-closure/","content":"这里讲一个简单的例子\n```\nfunction foo(){\n    var person = {\n        \"name\": \"joe\",\n        \"age\": 18\n    }\n\n    return function getValue(name){\n        return person[name];\n    }\n};\n\nvar bar = foo();\nbar('name'); //=> 'joe'\n\nObject.defineProperty(Object.prototype, 'self', {\n    get: function() {\n        return this;\n    }\n});\n\nbar('self'); //=> {name\": \"joe\", \"age\": 18}\n```\n至于这么不让他通过扩展原型链获取数据，重写`__proto__`即可\n","tags":["javascript"]},{"title":"原型继承方法","url":"/2017/05/18/inheritance-method/","content":"\n鉴于我十分容易忘记原型继承的方法，所以记录一下，方便复习_(:з」∠)_\n\n### 原型链继承\n```\nfunction SuperType(name){\n    this.name = name || \"joe\";\n}\n\nSuperType.prototype.getValue = function(name){\n    return this[name];\n}\n\nfunction SubType(age){\n    this.age = age || 18;\n}\n\nSubType.prototype = new SuperType(); //通过创建SuperType的实例继承，重写了原型对象\n//就是没法改到name\n\n```\n\n### 借用构造函数\n```\nfunction SuperType(){\n    this.name = \"joe\";\n}\n\nSuperType.prototype.getValue = function(name){\n    return this[name];\n}\n\nfunction SubType(age){\n    SuperType.call(this); //还可以传参哟\n    this.age = age || 18;\n}\n//没有继承到原型链\n\n```\n\n### 组合继承(借用并继承原型链)\n```\nfunction SuperType(){\n    this.name = \"joe\";\n}\n\nSuperType.prototype.getValue = function(name){\n    return this[name];\n}\n\nfunction SubType(age){\n    SuperType.call(this); //还可以传参哟\n    this.age = age || 18;\n}\n\nSubType.prototype = new SuperType();\n\n```\n\n### 共享原型\n```\nfunction SuperType(){\n    this.name = \"joe\";\n}\n\nSuperType.prototype.getValue = function(name){\n    return this[name];\n}\n\nfunction SubType(age){\n    this.age = age || 18;\n}\n\nSubType.prototype = SuperType.prototype;\n\n```\n\n### 临时借用构造函数\n```\nfunction inherit(sub, super){\n    function F(){};\n    F.prototype = super.prototype;\n    sub.prototype = new F();\n}\n```\n\n### 原型式继承\n借助原型可以基于已有的对象创建新的对象，还不用创建自定义类型\n与`Object.create`类型\n```\nfunction object(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\n```\n\n### 寄生式继承\n函数不能复用，会降低效率\n```\nfunction createAnother(original){\n    var clone = object(original);\n    clone.sayHi = function(){\n        alert(\"hi\");\n    };\n    return clone;\n}\n```\n\n### 寄生组合式继承\n```\nfunction inherit(sub, super){\n    var prototype = Object(super.prototype);\n    prototype.constructor = sub;\n    sub.prototype = prototype;\n}\n```\n\n### 复制继承\n\n","tags":["javascript"]},{"title":"操作符","url":"/2017/05/15/operator/","content":"\n忘记是在什么情形下遇到了一个问题：\n```\nnull >= 0 //=> true\nnull == 0 //=> false\nNumber(null) === 0 //=> true\n```\n在我过去的印象中，操作符会引起类型转换，如果一边是数字，另一边也应该转换为数字才对，但是代码的结果让我有限的大脑就陷入了沉思=L=\n\n大概在Stack Overflow上查了查后，我得到了答案。\n\n在**关系比较符号**对比两边时，遵循以下规则：\n* 如果两边都是数字，则进行数值比较\n* 如果两边都是字符串，则进行字符编码比较\n* 如果一边是数字，则将另一边转换为数字比较\n* 如果一边是布尔值，则会先转换为数值再比较\n* 如果一边是对象，则会先调用`valueOf`，如果返回值不能转换为数值，则会基于该值调用`toString`，然后再依据以上规则比较\n\n这样就可以解释为什么`null >= 0`结果是`true`了，因为关系比较符的一边是数字，因此将`null`转换为数字进行了比较，`0 >= 0`当然是`true`了\n\n但在**相等操作符**比较时，又有些不同：\n* 首先，`null` == `undefined`，因为undefined派生自`null`\n* 在比较相等性之前，不能将`null`和`undefined`转换为其他的值\n* NaN与任何值都不相等，包括他自己\n* 如果两边都是对象，则比较对象的指向\n\n根据第二点，可以得出为什么`null`和`0`不相等，因为没有发生类型转换，同理`undefined == 0`答案也是`false`。\n我们可以说`null`和`undefined`，除了对方和自己，和任何类型都是不等的\n\n顺便一提，`Object.is`也可以用来进行比较，它比较接近于全等，不同点在于\n```\n    Object.is(NaN, NaN) //=> true\n    Object.is(-0, +0) //=> true\n```\n\n","tags":["javascript"]},{"title":"数据类型","url":"/2017/05/15/data-structure/","content":"\n## 杂\n* `\"use strict\"`是编译指示，为了不破坏ES3语法特定选择。\n* JavaScript的变量是松散类型的。松散类型可以用来保存不同类型的数据。可以说变量仅是一个用于保存值的占位符而已。\n\n## 数据类型\n### Undefined\n* 派生自null\n* 代表着未声明或未初始化，但是试图使用未声明的变量会报错，`typeof`不会。\n    * 推荐做法： 显示声明变量，以区分未声明\n* 没有`toString`方法\n* **全局对象的一个属性**\n* undefined == null\n* void 0 === undefined，因为void运算符对给定的表达式进行求值，然后返回undefined。\n\n### Null\n* 表示空对象指针(空值、没有对象被呈现)，因此`typeof null === \"object\"`\n* 没有`toString`方法\n\n-----\n\n### Boolean\n\n### String\n* ES6可以使用模板字面量`hello ${world}`\n\n### Number\n* 八进制字面量，在严格模式下抛出错误\n```\n    function a() {\n        \"use strict\"\n        var a = 012;\n        console.log(a);\n    }\n    //Uncaught SyntaxError: Octal literals are not allowed in strict mode.\n```\n* 不能直接`toString`。假设是`2.toString()`，JavaScript会认为它是2.0和toString，然后报错，解决手段\n```\n2 .toString();\n(2).toString();\n```\n* `isFinite()`判断数值是否在最大值和最小值之间。入参会进行类型转换，object类型的值会先调用`valueOf`，如果返回值不能转换为数值，则会基于该值调用`toString`。\n* ```\n    Number(null) === 0;\n    isNaN(Number({})) === true; //对于对象的转换与isFinite同\n    isNaN(Number(undefined)) === true;\n    ```\n* parseInt在ES3中，有些值会被当成八进制字面量，如果不穿基数，所以最好还是要传基数。\n\n\n### 基本包装类型\n**!! JavaScript还拥有3个特殊的*基本包装类型*(Number、String、Boolean)**\n每当读取一个基本类型值的时候，后台就会创建一个相应的基本包装类型。\n（悄悄创建一个String类型的实例，然后在实例上调用方法...，使用完后销毁）\n```\n    var str = 'string';\n    str.substring(2); //创建一个String实例，在实例上调用方法, 使用后销毁\n    str.test = 123; //创建一个String实例，在实例上添加属性\n    console.log(str.test) //=> undefined 使用后已经被销毁\n```\n基本包装类型与引用类型的区别在于对象生存期，自动创建的基本包装类型对象，只存在于代码存在的一瞬间。\n\n而且与字面量也有所区别\n```\n    var str1 = 'string'; //(字符串字面量, 隐式创建的基本包装类型对象)\n    var str2 = new String('string'); //(字符串对象, 显示创建的基本包装类型对象)\n\n    typeof str1 //'string'\n    typeof str2 //'object'\n```\n\n-----\n\n### Object <u>**(复杂类型 | 引用类型)**</u>\n* **引用类型的值（对象）是引用类型的一个实例。引用类型是一种数据结构。**\n* 新对象是通过new 构造函数创建的，对象是某个特定引用类型的实例，保存在内存中，操作时操作的实际是对象的引用而不是实际对象\n* 构造函数本身也是函数\n* 通过创建Object实例的方法，可以创建自定义的对象\n* Object类型是它所有实例的基础，Object类型所具有的任何属性和方法也同样存在于更具体的对象中\n#### Object\n* 通过对象字面领定义对象时，在FF2就不会调用Object构造函数了\n* `new Object(null)`或`new Object(undefined)`返回结果与`new Object`相同\n* `new Object(true)`与`new Boolean(true)`等价, `new Object(2)`与`new Number(2)`等价\n* 当设定`__proto__`不是null或对象时，它是不会被改变的。在对象字面值中，仅有一次变更原型的机会；多次变更原型，会被视为语法错误。不使用冒号标记的属性定义，不会变更对象的原型；而是和其他具有不同名字的属性一样是普通属性定义。\n  ```\n    var __proto__ = \"variable\";\n    var obj1 = { __proto__ };\n    var obj2 = { __proto__: __proto__ };\n    var obj3 = { [\"__prot\" + \"o__\"]: __proto__ };\n    var obj4 = { __proto__() { return \"hello\"; } };\n    console.log(obj1.__proto__) //=>\"variable\"\n    console.log(obj2.__proto__) //=> Object.prototype\n    console.log(obj3.__proto__) //=>\"variable\"\n    console.log(obj4.__proto__) //=>\"variable\"\n  ```\n\n#### Array\n* 数组是类似列表的对象\n```\n    var arr1 = new Array(3); //=> [undefined × 3]\n    var arr2 = Array.apply(null, arr1) //=> [undefined, undefined, undefined]\n    var arr3 = Array.apply(null, {length: 3}) //=> [undefined, undefined, undefined]\n    //因为apply()的第二个参数是数组或类数组\n```\n\n#### Date\n*  `+new Date`可以获得时间戳\n\n#### RegExp\n\n#### Function\n* 每个函数都是Function的实例\n* Function对象继承自 Function.prototype 属性\n* 函数名其实是一个指向函数对象的指针（函数是对象，函数名是指针）\n* 解析器会率先读取函数声明（函数声明提升），而通过函数表达式声明的函数，必须等待解析器执行到他的位置\n* 参数只是副本\n\n\n##### 加一笔转换规则\n1. `!`开头会被转换成布尔\n2. `+`开头转换成数值\n3. `[]`开头的转换成字符串\n","tags":["javascript"]},{"title":"在HTML中使用JavaScript","url":"/2017/05/15/use-javascript-in-html/","content":"\n唔……是的，本来实在看JavaScript高级程序设计的，但是一不小心忘记之前看到哪里了，\n所以我要开始第四次、还不知道是第五次开始从头看起了_(:з」∠)_\n\n不过也好，便于我记忆吧~喵喵喵\n\n下记内容仅包含我可能会忘记的\n* 属性(大概不会用的那种)\n    * async\n    * defer\n    * src 可跨域\n* `<script>`标签内容由上至下解释\n* 外部文件扩展名不是.js也可以，只要能返回正确的MIME类型\n* 不申明doctype会开启混杂模式\n    * 混杂模式：不同浏览器呈现不同行为差异\n    * 标准模式：浏览器行为接近标准行为","tags":["javascript"]},{"title":"初始化","url":"/2017/05/15/hello-world/","content":"\nThis is my very first blog!!\n\n(\\*´ｪ`\\*)\n\nHave a good time!\n\n\n事实上，我觉得我大概也不会频繁的写_(:з」∠)_\n毕竟我是一个大懒人……\n可能会把简书上的内容搬过来吧……\n好像我老是忘记有简书这回事情，完全不记得有写\n不过最近一直痴迷于写外包什么的辣……完全没有什么写中文的欲望\n唔……祝我好好学习天天向上吧o(￣ε￣*)","tags":["diary"]},{"title":"About","url":"/about/index.html","content":"\n在下 **魔力叉烧包**\n\n主营业务：撸React\n生产日期：18年前\n保质期：约100年\n产地：杭州\n\n"},{"title":"用canvas绘制视频(然而并没有什么卵用)","url":"/demo/canvas-video.html","content":"[参考](https://developer.mozilla.org/en-US/Apps/Fundamentals/Audio_and_video_delivery/Cross-browser_audio_basics)<br>\n亲测在ip6上会全屏播放，并没有什么卵用<br>\n据说在更之前的浏览器(大概13年及之前那波)一定要把video渲染在dom里面才能用<br>\n如果想获取更高帧频，应考虑用raf方法替换timeupdate方法<br>\n\n<div>\n    <button id=\"button\">播放</button>\n    <br/>\n    <canvas id=\"player\" width=\"500\" height=\"300\" style=\"background: #000\">canvas</canvas>\n</div>\n<script>\nfunction playVideo() {\n    if( video.ended || video.paused ) return;\n    context.drawImage(video, 0, 0, player.width, player.height);\n    console.log('requestAnimationFrame: '+ video.currentTime);\n    requestAnimationFrame(playVideo);\n};\nvar player = document.querySelector(\"#player\");\nvar context = player.getContext(\"2d\");\nvar button = document.querySelector(\"#button\");\nvar video = document.createElement(\"video\");\nvideo.addEventListener(\"loadeddata\", function(){\n    console.log(\"loaded video data!\");\n    //player.width = video.videoWidth;\n    //player.height = video.videoHeight;\n});\nvideo.addEventListener(\"timeupdate\", function(event){\n    console.log(\"timeupdate: \" + video.currentTime);\n    button.innerText = \"播放\";    \n});\nvideo.preload = \"auto\";\nvideo.src = \"http://gslb.miaopai.com/stream/acqw7E1g2UQz3vvfwTkwPUH1xpI07LAbzgm-Iw__.mp4?ssig=fc558e33c84a0723f0e3000b21287c8a&time_stamp=1505187251951&cookie_id=&vend=1&os=3&partner=1&platform=2&cookie_id=&refer=miaopai&scid=acqw7E1g2UQz3vvfwTkwPUH1xpI07LAbzgm-Iw__\";\nbutton.addEventListener(\"click\", function(){\n    if ( video.paused ) {\n        button.innerHTML = \"暂停\";\n        video.play();\n        requestAnimationFrame(playVideo);\n    } else {\n        video.pause();\n        button.innerHTML = \"播放\";\n    }\n});\n</script>\n\n```html\n<button id=\"button\">播放</button>\n<br/>\n<canvas id=\"player\" width=\"500\" height=\"300\" style=\"background: #000\">canvas</canvas>\n```\n\n```javascript\nvar player = document.querySelector(\"#player\");\nvar context = player.getContext(\"2d\");\nvar button = document.querySelector(\"#button\");\nvar video = document.createElement(\"video\");\nvideo.addEventListener(\"loadeddata\", function(){\n    console.log(\"loaded video data!\");\n    //player.width = video.videoWidth;\n    //player.height = video.videoHeight;\n});\nvideo.addEventListener(\"timeupdate\", function(event){\n    console.log(\"timeupdate: \" + video.currentTime);\n    button.innerText = \"播放\";    \n});\nvideo.preload = \"auto\";\nvideo.src = \"http://gslb.miaopai.com/stream/acqw7E1g2UQz3vvfwTkwPUH1xpI07LAbzgm-Iw__.mp4?ssig=fc558e33c84a0723f0e3000b21287c8a&time_stamp=1505187251951&cookie_id=&vend=1&os=3&partner=1&platform=2&cookie_id=&refer=miaopai&scid=acqw7E1g2UQz3vvfwTkwPUH1xpI07LAbzgm-Iw__\";\nbutton.addEventListener(\"click\", function(){\n    if ( video.paused ) {\n        button.innerHTML = \"暂停\";\n        video.play();\n        requestAnimationFrame(playVideo);\n    } else {\n        video.pause();\n        button.innerHTML = \"播放\";\n    }\n});\n\nfunction playVideo() {\n    if( video.ended || video.paused ) return;\n    context.drawImage(video, 0, 0, player.width, player.height);\n    console.log('requestAnimationFrame: '+ video.currentTime);\n    requestAnimationFrame(playVideo);\n}\n```\n\n"},{"title":"请求并发笔记","url":"/demo/request-concurrency.html","content":"[参考](https://www.zhihu.com/question/20474326)\n\n# 整理总结\n\n## 浏览器的并发请求数目限制是针对同一域名的。\n意即，同一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。\n*另外，如果请求静态资源与主站在同一域名下，会把不需要的cookie信息带过去，造成资源浪费*[详见]\n(http://webmasters.stackexchange.com/questions/26753/why-do-big-sites-host-their-images-css-on-external-domains）\n\n## 不同浏览器的并发数\n\n|Browser|HTTP/1.1|HTTP/1.0|\n|-------|--------|--------|\n|IE 6,7\t|2|4|\n|IE 8   |6|6|\n|Firefox 2|2|8|\n|Firefox 3|6|6|\n|Safari 3,4|4|4|\n|Chrome 1,2|6|?|\n|Chrome 3|4|4|\n|Chrome 4+|6|?|\n|iPhone 2|4|?|\n|iPhone 3|6|?|\n|iPhone 4|4|?|\n|Opera 9.63,10.00alpha|4|4|\n|Opera 10.51+|8|?|\n\n\n\n\n\n\n"},{"title":"demo","url":"/demo/index.html","content":"喵喵喵"},{"title":"setTimeout总结","url":"/demo/settimeout-learning.html","content":"_(:з」∠)_ \n关于setTimeout的总结向\n### setTimeout不能作为多线程使用，js引擎执行是单线程的\n最好证明：\n```javascript\nvar isEnd = true;\nwindow.setTimeout(function () {\n    isEnd = false;//1s后，改变isEnd的值\n}, 1000);\nwhile (isEnd);\nalert('end');\n```\n这段代码会死循环\n\n### js是基于事件驱动的语言.它的执行顺序是遵循一个叫做事件队列的机制\n执行的时候就是在逐步执行队列里面的事务。\nsetTimeout就是，线程会在指定时间后往事件队列里面插入一个任务。\n\n### js引擎与GUI引擎是互斥的\nGUI引擎在渲染时会阻塞js引擎计算。\n如果在GUI渲染的时候,js改变了dom,那么就会造成渲染不同步。\n异步操作都会被延迟到同步计算之后执行.也就是代码的执行顺序变了。\n\n### requestAnimationFrame\n* requestAnimationFrame 会**把每一帧中的所有DOM操作集中起来**，**在一次重绘或回流中就完成**，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧,每帧大约16毫秒.\n* **在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流**，这当然就意味着更少的的cpu，gpu和内存使用量。\n* 但它优于setTimeout/setInterval的地方在于它是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且**如果页面不是激活状态下的话，动画会自动暂停**，有效节省了CPU开销。\n\n### 总结\n* **浏览器的内核是多线程的**，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：**javascript引擎线程**，**GUI渲染线程**，**浏览器事件触发线程**。\n* javascript引擎是**基于事件驱动单线程执行**的.JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。\n* 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但需要注意 **GUI渲染线程与JS引擎是互斥的**，**当JS引擎执行时GUI线程会被挂起**，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\n* 当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。\n"},{"title":"Mac通过ssh免密登录Linux","url":"/demo/ssh-mac-linux.html","content":"1. `ssh-keygen -t rsa -C 'danningmao@outlook.com'`\n2. `scp ~/.ssh/id_rsa.pub username@hostname:~/`\n3. `ssh username@hostname`\n4. `mkdir .ssh`(optional)\n5. `cat id_rsa.pub >> .ssh/authorized_keys`\n6. `vim ~/.ssh/config`\n7. `Host        alias #自定义别名\n    HostName        hostname  #替换为你的ssh服务器ip或domain\n    Port            port #ssh服务器端口，默认为22\n    User            user #ssh服务器用户名\n    IdentityFile    ~/.ssh/id_rsa #第一个步骤生成的公钥文件对应的私钥文件`\n8. `ssh alias #alias是你在~/.ssh/config文件配置的别名`"},{"title":"tags","url":"/tags/index.html"},{"title":"垂直居中demo","url":"/demo/vertical-center.html","content":"<div style=\"height: 200px; line-height: 200px; text-align: center;border: 1px solid #ddd; margin: 10px\">\n    <span>文字的垂直居中</span>\n</div>\n```html\n<div style=\"height: 200px; line-height: 200px; text-align: center;border: 1px solid #ddd; margin: 10px\">\n    <span>文字的垂直居中</span>\n</div>\n```\n<div style=\"height: 200px; line-height: 200px; text-align: center;font-size: 0; border: 1px solid #ddd; margin: 10px\">\n    <span style=\"font-size: 12px; display: inline-block; line-height: 1.5; vertical-align: middle\">\n        多行文字垂直居中多行文字垂直居中多行文字垂直居中<br>\n        多行文字垂直居中多行文字垂直居中多行文字垂直居中<br>\n        多行文字垂直居中多行文字垂直居中多行文字垂直居中多行文字垂直居中\n    </span>\n    <span style=\"display: inline-block; vertical-align: middle\"></span>\n</div>\n```html\n<div style=\"height: 200px; line-height: 200px; text-align: center;font-size: 0; border: 1px solid #ddd; margin: 10px\">\n    <span style=\"font-size: 12px; display: inline-block; line-height: 1.5; vertical-align: middle\">\n        多行文字垂直居中多行文字垂直居中多行文字垂直居中<br>\n        多行文字垂直居中多行文字垂直居中多行文字垂直居中<br>\n        多行文字垂直居中多行文字垂直居中多行文字垂直居中多行文字垂直居中\n    </span>\n    <span style=\"display: inline-block; vertical-align: middle\"></span>\n</div>\n```\n<div style=\"height: 200px; width: 500px; max-width: 500px; text-align: center; display: table-cell; vertical-align: middle; border: 1px solid #ddd;\">\n    <p>多行文字</p>\n    <p>多行文字</p>\n    <p>多行文字</p>\n    <p>多行文字</p>\n</div>\n```html\n<div style=\"height: 200px; width: 500px; max-width: 500px; text-align: center; display: table-cell; vertical-align: middle; border: 1px solid #ddd;\">\n    <p>多行文字</p>\n    <p>多行文字</p>\n    <p>多行文字</p>\n    <p>多行文字</p>\n</div>\n```\n<div style=\"height: 200px; width: 100%; display: table;border: 1px solid #ddd; margin: 10px\">\n    <div style=\"display:table-cell;vertical-align:middle;text-align:center\">\n        <div style=\"margin-left:auto;margin-right:auto; width: 50px; height: auto; background: pink\">\n            不定高不定宽垂直居中\n        </div>\n    </div>\n</div>\n```html\n<div style=\"height: 200px; width: 100%; display: table;border: 1px solid #ddd; margin: 10px\">\n    <div style=\"display:table-cell;vertical-align:middle;text-align:center\">\n        <div style=\"margin-left:auto;margin-right:auto; width: 50px; height: auto; background: pink\">\n            不定高不定宽垂直居中\n        </div>\n    </div>\n</div>\n```\n<div style=\"height: 200px; text-align: center;border: 1px solid #ddd; margin: 10px; position: relative\">\n    <div style=\"margin-left: -25px; margin-top: -25px; position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: pink\">\n        定高定宽垂直居中\n    </div>\n</div>\n```html\n<div style=\"height: 200px; text-align: center;border: 1px solid #ddd; margin: 10px; position: relative\">\n    <div style=\"margin-left: -25px; margin-top: -25px; position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: pink\">\n        定高定宽垂直居中\n    </div>\n</div>\n```\n<div style=\"height: 200px; text-align: center;border: 1px solid #ddd; margin: 10px; position: relative\">\n    <div style=\"margin: auto; position: absolute; top: 0; left: 0; right: 0; bottom: 0;width: 50px; height: 50px; background: pink\">\n        定高定宽垂直居中\n    </div>\n</div>\n```html\n<div style=\"height: 200px; text-align: center;border: 1px solid #ddd; margin: 10px; position: relative\">\n    <div style=\"margin: auto; position: absolute; top: 0; left: 0; right: 0; bottom: 0;width: 50px; height: 50px; background: pink\">\n        定高定宽垂直居中\n    </div>\n</div>\n```\n<div style=\"height: 200px; text-align: center;border: 1px solid #ddd; margin: 10px; position: relative\">\n    <div style=\"width: 50px; background: pink; position: absolute; top: 50%;  transform: translate3d(-50%, -50%, 0); left: 50%\">\n        不定高定宽垂直居中\n    </div>\n</div>\n```html\n<div style=\"height: 200px; text-align: center;border: 1px solid #ddd; margin: 10px; position: relative\">\n    <div style=\"width: 50px; background: pink; position: absolute; top: 50%;  transform: translate3d(-50%, -50%, 0); left: 50%\">\n        不定高定宽垂直居中\n    </div>\n</div>\n```\n<div style=\"display:flex;justify-content:center;align-items:center;width:100%;height:200px;border: 1px solid #ddd; margin: 10px;\">\n    <div>flex垂直居中</div>\n</div>\n```html\n<div style=\"display:flex;justify-content:center;align-items:center;width:100%;height:200px;border: 1px solid #ddd; margin: 10px;\">\n    <div>flex垂直居中</div>\n</div>\n```"}]